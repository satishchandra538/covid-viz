!function(t){var n={};function I(g){if(n[g])return n[g].exports;var c=n[g]={i:g,l:!1,exports:{}};return t[g].call(c.exports,c,c.exports,I),c.l=!0,c.exports}I.m=t,I.c=n,I.d=function(t,n,g){I.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:g})},I.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},I.t=function(t,n){if(1&n&&(t=I(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var g=Object.create(null);if(I.r(g),Object.defineProperty(g,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var c in t)I.d(g,c,function(n){return t[n]}.bind(null,c));return g},I.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return I.d(n,"a",n),n},I.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},I.p="",I(I.s=0)}([function(module,exports,__webpack_require__){eval('var donutChart = __webpack_require__(1);\r\nmultiLineGraph = __webpack_require__(2);\r\n//window.multiLineGraph = multiLineGraph;\r\n\r\nconst countrySelection = document.getElementById("countrySelection");\r\nconst totalConfirmedInDoc = document.getElementById("totalConfirmed");\r\nconst totalDeathsInDoc = document.getElementById("totalDeaths");\r\nconst totalRecoveredInDoc = document.getElementById("totalRecovered");\r\nconst totalDeathRateInDoc = document.getElementById("deathRate");\r\nconst totalRecoveryRateInDoc = document.getElementById("recoveryRate");\r\nconst worldTable = document.getElementById("worldTable");\r\n\r\ncountries = {};\r\nwindow.days = 0;\r\n//Tool tip div element\r\ndiv = d3\r\n    .select(\'body\')\r\n    .append(\'div\')\r\n    .attr(\'class\', \'tooltip\')\r\n\r\nconst fetchData = async () => {\r\n    const data = await fetch(\'https://pomber.github.io/covid19/timeseries.json\');\r\n    const jsonData = await data.json();\r\n\r\n    countries = Object.keys(jsonData).map((country) => {\r\n        return [country, jsonData[country]]\r\n    })\r\n    //parsing date\r\n    var parseDate = d3.timeParse("%Y-%m-%d");\r\n    countries.forEach(country => {\r\n        country[1].forEach(day => {\r\n            day.date = parseDate(day.date)\r\n        })\r\n    })\r\n\r\n    days = countries[0][1].length;\r\n\r\n    //add countrySelection\r\n    let totalConfirmed = 0;\r\n    let totalDeath = 0;\r\n    let totalRecovered = 0;\r\n    let totalConfirmedChange = 0;\r\n    let totalDeathChange = 0;\r\n    let totalRecoveredChange = 0;\r\n    let countryWithHighestDeathRate = 0;\r\n\r\n    countries.forEach(country => {\r\n        const days = country[1].length;\r\n        totalConfirmed += country[1][days - 1].confirmed;\r\n        totalConfirmedChange += country[1][days - 2].confirmed\r\n        totalRecovered += country[1][days - 1].recovered;\r\n        totalRecoveredChange += country[1][days - 2].recovered;\r\n        totalDeath += country[1][days - 1].deaths;\r\n        totalDeathChange += country[1][days - 2].deaths;\r\n        countryWithHighestDeathRate = countryWithHighestDeathRate > (country[1][days - 2].deaths / country[1][days - 2].confirmed) * 100 ? countryWithHighestDeathRate : (country[1][days - 2].deaths / country[1][days - 2].confirmed) * 100;\r\n    })\r\n\r\n    let totalActive = totalConfirmed - totalDeath - totalRecovered;\r\n    totalConfirmedInDoc.innerHTML = totalConfirmed + `<span class="change"> (${totalConfirmed - totalConfirmedChange}+)</span>`;\r\n    totalDeathsInDoc.innerHTML = totalDeath + `<span class="change"> (${totalDeath - totalDeathChange}+)</span>`;\r\n    totalRecoveredInDoc.innerHTML = totalRecovered + `<span class="change"> (${totalRecovered - totalRecoveredChange}+)</span>`;\r\n    let totalDeathRate = Math.floor((totalDeath * 100 / totalConfirmed) * 100) / 100;\r\n    totalDeathRateInDoc.innerHTML = totalDeathRate + "%";\r\n    let totalRecoveryRate = Math.floor((totalRecovered * 100 / totalConfirmed) * 100) / 100;\r\n    totalRecoveryRateInDoc.innerHTML = totalRecoveryRate + "%";\r\n\r\n    //--------Adding Donut char for whole wold data---------\r\n    donutChart(totalActive, totalDeath, totalRecovered);\r\n\r\n    //--------Adding Multiline Graph------------------------\r\n    multiLineGraph(countries, days, numberOfCountriesInLineChart);\r\n\r\n    //--------Table making----------------------------------\r\n    countries.forEach((country, index) => {\r\n        let TR = document.createElement("tr");\r\n        let TDcountry = document.createElement("td");\r\n        let TDcases = document.createElement("td");\r\n        let TDdeath = document.createElement("td");\r\n        let TDdeathrate = document.createElement("td");\r\n        let countryDeathRate = ((country[1][days - 1].deaths * 100) / country[1][days - 1].confirmed).toFixed(1);\r\n        if (countryDeathRate < 10) {\r\n            countryDeathRate = ". " + countryDeathRate;\r\n        }\r\n        let barWidth = (((country[1][days - 1].deaths / country[1][days - 1].confirmed) * 100) / countryWithHighestDeathRate) * 150;\r\n        let deathRateBar = `<svg width="100" height="20">\r\n            <rect width=${barWidth} height="20" fill="brown"></rect>\r\n        </svg>`\r\n        TDcountry.innerHTML = `${country[0]}`;\r\n        TDcases.innerHTML = country[1][days - 1].confirmed;\r\n        TDdeath.innerHTML = country[1][days - 1].deaths;\r\n        TDdeathrate.innerHTML = countryDeathRate + "% " + deathRateBar;\r\n        TR.append(TDcountry, TDcases, TDdeath, TDdeathrate)\r\n        worldTable.appendChild(TR);\r\n    })\r\n\r\n}\r\nfetchData()\r\n\r\n///////////filter in table\r\nwindow.searchCountry = () => {\r\n    var input, filter, table, tr, td, i, txtValue;\r\n    input = document.getElementById("tableSearchInput");\r\n    filter = input.value.toUpperCase();\r\n    table = worldTable.parentNode;\r\n    tr = table.getElementsByTagName("tr");\r\n    for (i = 0; i < tr.length; i++) {\r\n        td = tr[i].getElementsByTagName("td")[0];\r\n        if (td) {\r\n            txtValue = td.textContent || td.innerText;\r\n            if (txtValue.toUpperCase().indexOf(filter) > -1) {\r\n                tr[i].style.display = "";\r\n            } else {\r\n                tr[i].style.display = "none";\r\n            }\r\n        }\r\n    }\r\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY3JpcHQuanM/ZjdhNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxDQUFjO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLENBQWtCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrRUFBK0Usc0NBQXNDO0FBQ3JILHdFQUF3RSw4QkFBOEI7QUFDdEcsK0VBQStFLHNDQUFzQztBQUNySDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZG9udXRDaGFydCA9IHJlcXVpcmUoJy4vZG9udXRDaGFydCcpO1xyXG5tdWx0aUxpbmVHcmFwaCA9IHJlcXVpcmUoJy4vbXVsdGlMaW5lR3JhcGgnKTtcclxuLy93aW5kb3cubXVsdGlMaW5lR3JhcGggPSBtdWx0aUxpbmVHcmFwaDtcclxuXHJcbmNvbnN0IGNvdW50cnlTZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvdW50cnlTZWxlY3Rpb25cIik7XHJcbmNvbnN0IHRvdGFsQ29uZmlybWVkSW5Eb2MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRvdGFsQ29uZmlybWVkXCIpO1xyXG5jb25zdCB0b3RhbERlYXRoc0luRG9jID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0b3RhbERlYXRoc1wiKTtcclxuY29uc3QgdG90YWxSZWNvdmVyZWRJbkRvYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidG90YWxSZWNvdmVyZWRcIik7XHJcbmNvbnN0IHRvdGFsRGVhdGhSYXRlSW5Eb2MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlYXRoUmF0ZVwiKTtcclxuY29uc3QgdG90YWxSZWNvdmVyeVJhdGVJbkRvYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVjb3ZlcnlSYXRlXCIpO1xyXG5jb25zdCB3b3JsZFRhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ3b3JsZFRhYmxlXCIpO1xyXG5cclxuY291bnRyaWVzID0ge307XHJcbndpbmRvdy5kYXlzID0gMDtcclxuLy9Ub29sIHRpcCBkaXYgZWxlbWVudFxyXG5kaXYgPSBkM1xyXG4gICAgLnNlbGVjdCgnYm9keScpXHJcbiAgICAuYXBwZW5kKCdkaXYnKVxyXG4gICAgLmF0dHIoJ2NsYXNzJywgJ3Rvb2x0aXAnKVxyXG5cclxuY29uc3QgZmV0Y2hEYXRhID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoKCdodHRwczovL3BvbWJlci5naXRodWIuaW8vY292aWQxOS90aW1lc2VyaWVzLmpzb24nKTtcclxuICAgIGNvbnN0IGpzb25EYXRhID0gYXdhaXQgZGF0YS5qc29uKCk7XHJcblxyXG4gICAgY291bnRyaWVzID0gT2JqZWN0LmtleXMoanNvbkRhdGEpLm1hcCgoY291bnRyeSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBbY291bnRyeSwganNvbkRhdGFbY291bnRyeV1dXHJcbiAgICB9KVxyXG4gICAgLy9wYXJzaW5nIGRhdGVcclxuICAgIHZhciBwYXJzZURhdGUgPSBkMy50aW1lUGFyc2UoXCIlWS0lbS0lZFwiKTtcclxuICAgIGNvdW50cmllcy5mb3JFYWNoKGNvdW50cnkgPT4ge1xyXG4gICAgICAgIGNvdW50cnlbMV0uZm9yRWFjaChkYXkgPT4ge1xyXG4gICAgICAgICAgICBkYXkuZGF0ZSA9IHBhcnNlRGF0ZShkYXkuZGF0ZSlcclxuICAgICAgICB9KVxyXG4gICAgfSlcclxuXHJcbiAgICBkYXlzID0gY291bnRyaWVzWzBdWzFdLmxlbmd0aDtcclxuXHJcbiAgICAvL2FkZCBjb3VudHJ5U2VsZWN0aW9uXHJcbiAgICBsZXQgdG90YWxDb25maXJtZWQgPSAwO1xyXG4gICAgbGV0IHRvdGFsRGVhdGggPSAwO1xyXG4gICAgbGV0IHRvdGFsUmVjb3ZlcmVkID0gMDtcclxuICAgIGxldCB0b3RhbENvbmZpcm1lZENoYW5nZSA9IDA7XHJcbiAgICBsZXQgdG90YWxEZWF0aENoYW5nZSA9IDA7XHJcbiAgICBsZXQgdG90YWxSZWNvdmVyZWRDaGFuZ2UgPSAwO1xyXG4gICAgbGV0IGNvdW50cnlXaXRoSGlnaGVzdERlYXRoUmF0ZSA9IDA7XHJcblxyXG4gICAgY291bnRyaWVzLmZvckVhY2goY291bnRyeSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGF5cyA9IGNvdW50cnlbMV0ubGVuZ3RoO1xyXG4gICAgICAgIHRvdGFsQ29uZmlybWVkICs9IGNvdW50cnlbMV1bZGF5cyAtIDFdLmNvbmZpcm1lZDtcclxuICAgICAgICB0b3RhbENvbmZpcm1lZENoYW5nZSArPSBjb3VudHJ5WzFdW2RheXMgLSAyXS5jb25maXJtZWRcclxuICAgICAgICB0b3RhbFJlY292ZXJlZCArPSBjb3VudHJ5WzFdW2RheXMgLSAxXS5yZWNvdmVyZWQ7XHJcbiAgICAgICAgdG90YWxSZWNvdmVyZWRDaGFuZ2UgKz0gY291bnRyeVsxXVtkYXlzIC0gMl0ucmVjb3ZlcmVkO1xyXG4gICAgICAgIHRvdGFsRGVhdGggKz0gY291bnRyeVsxXVtkYXlzIC0gMV0uZGVhdGhzO1xyXG4gICAgICAgIHRvdGFsRGVhdGhDaGFuZ2UgKz0gY291bnRyeVsxXVtkYXlzIC0gMl0uZGVhdGhzO1xyXG4gICAgICAgIGNvdW50cnlXaXRoSGlnaGVzdERlYXRoUmF0ZSA9IGNvdW50cnlXaXRoSGlnaGVzdERlYXRoUmF0ZSA+IChjb3VudHJ5WzFdW2RheXMgLSAyXS5kZWF0aHMgLyBjb3VudHJ5WzFdW2RheXMgLSAyXS5jb25maXJtZWQpICogMTAwID8gY291bnRyeVdpdGhIaWdoZXN0RGVhdGhSYXRlIDogKGNvdW50cnlbMV1bZGF5cyAtIDJdLmRlYXRocyAvIGNvdW50cnlbMV1bZGF5cyAtIDJdLmNvbmZpcm1lZCkgKiAxMDA7XHJcbiAgICB9KVxyXG5cclxuICAgIGxldCB0b3RhbEFjdGl2ZSA9IHRvdGFsQ29uZmlybWVkIC0gdG90YWxEZWF0aCAtIHRvdGFsUmVjb3ZlcmVkO1xyXG4gICAgdG90YWxDb25maXJtZWRJbkRvYy5pbm5lckhUTUwgPSB0b3RhbENvbmZpcm1lZCArIGA8c3BhbiBjbGFzcz1cImNoYW5nZVwiPiAoJHt0b3RhbENvbmZpcm1lZCAtIHRvdGFsQ29uZmlybWVkQ2hhbmdlfSspPC9zcGFuPmA7XHJcbiAgICB0b3RhbERlYXRoc0luRG9jLmlubmVySFRNTCA9IHRvdGFsRGVhdGggKyBgPHNwYW4gY2xhc3M9XCJjaGFuZ2VcIj4gKCR7dG90YWxEZWF0aCAtIHRvdGFsRGVhdGhDaGFuZ2V9Kyk8L3NwYW4+YDtcclxuICAgIHRvdGFsUmVjb3ZlcmVkSW5Eb2MuaW5uZXJIVE1MID0gdG90YWxSZWNvdmVyZWQgKyBgPHNwYW4gY2xhc3M9XCJjaGFuZ2VcIj4gKCR7dG90YWxSZWNvdmVyZWQgLSB0b3RhbFJlY292ZXJlZENoYW5nZX0rKTwvc3Bhbj5gO1xyXG4gICAgbGV0IHRvdGFsRGVhdGhSYXRlID0gTWF0aC5mbG9vcigodG90YWxEZWF0aCAqIDEwMCAvIHRvdGFsQ29uZmlybWVkKSAqIDEwMCkgLyAxMDA7XHJcbiAgICB0b3RhbERlYXRoUmF0ZUluRG9jLmlubmVySFRNTCA9IHRvdGFsRGVhdGhSYXRlICsgXCIlXCI7XHJcbiAgICBsZXQgdG90YWxSZWNvdmVyeVJhdGUgPSBNYXRoLmZsb29yKCh0b3RhbFJlY292ZXJlZCAqIDEwMCAvIHRvdGFsQ29uZmlybWVkKSAqIDEwMCkgLyAxMDA7XHJcbiAgICB0b3RhbFJlY292ZXJ5UmF0ZUluRG9jLmlubmVySFRNTCA9IHRvdGFsUmVjb3ZlcnlSYXRlICsgXCIlXCI7XHJcblxyXG4gICAgLy8tLS0tLS0tLUFkZGluZyBEb251dCBjaGFyIGZvciB3aG9sZSB3b2xkIGRhdGEtLS0tLS0tLS1cclxuICAgIGRvbnV0Q2hhcnQodG90YWxBY3RpdmUsIHRvdGFsRGVhdGgsIHRvdGFsUmVjb3ZlcmVkKTtcclxuXHJcbiAgICAvLy0tLS0tLS0tQWRkaW5nIE11bHRpbGluZSBHcmFwaC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgbXVsdGlMaW5lR3JhcGgoY291bnRyaWVzLCBkYXlzLCBudW1iZXJPZkNvdW50cmllc0luTGluZUNoYXJ0KTtcclxuXHJcbiAgICAvLy0tLS0tLS0tVGFibGUgbWFraW5nLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgY291bnRyaWVzLmZvckVhY2goKGNvdW50cnksIGluZGV4KSA9PiB7XHJcbiAgICAgICAgbGV0IFRSID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xyXG4gICAgICAgIGxldCBURGNvdW50cnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XHJcbiAgICAgICAgbGV0IFREY2FzZXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XHJcbiAgICAgICAgbGV0IFREZGVhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XHJcbiAgICAgICAgbGV0IFREZGVhdGhyYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xyXG4gICAgICAgIGxldCBjb3VudHJ5RGVhdGhSYXRlID0gKChjb3VudHJ5WzFdW2RheXMgLSAxXS5kZWF0aHMgKiAxMDApIC8gY291bnRyeVsxXVtkYXlzIC0gMV0uY29uZmlybWVkKS50b0ZpeGVkKDEpO1xyXG4gICAgICAgIGlmIChjb3VudHJ5RGVhdGhSYXRlIDwgMTApIHtcclxuICAgICAgICAgICAgY291bnRyeURlYXRoUmF0ZSA9IFwiLiBcIiArIGNvdW50cnlEZWF0aFJhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBiYXJXaWR0aCA9ICgoKGNvdW50cnlbMV1bZGF5cyAtIDFdLmRlYXRocyAvIGNvdW50cnlbMV1bZGF5cyAtIDFdLmNvbmZpcm1lZCkgKiAxMDApIC8gY291bnRyeVdpdGhIaWdoZXN0RGVhdGhSYXRlKSAqIDE1MDtcclxuICAgICAgICBsZXQgZGVhdGhSYXRlQmFyID0gYDxzdmcgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIyMFwiPlxyXG4gICAgICAgICAgICA8cmVjdCB3aWR0aD0ke2JhcldpZHRofSBoZWlnaHQ9XCIyMFwiIGZpbGw9XCJicm93blwiPjwvcmVjdD5cclxuICAgICAgICA8L3N2Zz5gXHJcbiAgICAgICAgVERjb3VudHJ5LmlubmVySFRNTCA9IGAke2NvdW50cnlbMF19YDtcclxuICAgICAgICBURGNhc2VzLmlubmVySFRNTCA9IGNvdW50cnlbMV1bZGF5cyAtIDFdLmNvbmZpcm1lZDtcclxuICAgICAgICBURGRlYXRoLmlubmVySFRNTCA9IGNvdW50cnlbMV1bZGF5cyAtIDFdLmRlYXRocztcclxuICAgICAgICBURGRlYXRocmF0ZS5pbm5lckhUTUwgPSBjb3VudHJ5RGVhdGhSYXRlICsgXCIlIFwiICsgZGVhdGhSYXRlQmFyO1xyXG4gICAgICAgIFRSLmFwcGVuZChURGNvdW50cnksIFREY2FzZXMsIFREZGVhdGgsIFREZGVhdGhyYXRlKVxyXG4gICAgICAgIHdvcmxkVGFibGUuYXBwZW5kQ2hpbGQoVFIpO1xyXG4gICAgfSlcclxuXHJcbn1cclxuZmV0Y2hEYXRhKClcclxuXHJcbi8vLy8vLy8vLy8vZmlsdGVyIGluIHRhYmxlXHJcbndpbmRvdy5zZWFyY2hDb3VudHJ5ID0gKCkgPT4ge1xyXG4gICAgdmFyIGlucHV0LCBmaWx0ZXIsIHRhYmxlLCB0ciwgdGQsIGksIHR4dFZhbHVlO1xyXG4gICAgaW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRhYmxlU2VhcmNoSW5wdXRcIik7XHJcbiAgICBmaWx0ZXIgPSBpbnB1dC52YWx1ZS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgdGFibGUgPSB3b3JsZFRhYmxlLnBhcmVudE5vZGU7XHJcbiAgICB0ciA9IHRhYmxlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHJcIik7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0ZCA9IHRyW2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGRcIilbMF07XHJcbiAgICAgICAgaWYgKHRkKSB7XHJcbiAgICAgICAgICAgIHR4dFZhbHVlID0gdGQudGV4dENvbnRlbnQgfHwgdGQuaW5uZXJUZXh0O1xyXG4gICAgICAgICAgICBpZiAodHh0VmFsdWUudG9VcHBlckNhc2UoKS5pbmRleE9mKGZpbHRlcikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdHJbaV0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cltpXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},function(module,exports){eval("const donutChart = (totalActive, totalDeath, totalRecovered) => {\r\n    var pieCharParent = document.getElementById('worldActivePieChart').parentElement;\r\n    var pieChartWidth = pieCharParent.offsetWidth * 0.6;\r\n    var radius = pieChartWidth / 2;\r\n    const donutData = [{ label: 'totalRecovered', value: totalRecovered },\r\n    { label: 'totalActive', value: totalActive },\r\n    { label: 'totalDeath', value: totalDeath }];\r\n\r\n    var svg = d3.select(\"#worldActivePieChart\")\r\n        .attr(\"width\", pieCharParent.offsetWidth)\r\n        .attr(\"height\", pieCharParent.offsetWidth / 1.2)\r\n        .append('g')\r\n        .attr('transform', `translate(${pieChartWidth / 1.2},${pieChartWidth / 1.2})`)\r\n\r\n    var color = d3.scaleOrdinal()\r\n        .domain(donutData.map(d => d.label))\r\n        .range(d3.schemeDark2);\r\n\r\n    var pie = d3.pie()\r\n        .value(function (d) { return d.value.value; })\r\n    var data_ready = pie(d3.entries(donutData))\r\n\r\n    var arc = d3.arc()\r\n        .innerRadius(radius * 0.5)\r\n        .outerRadius(radius * 0.8)\r\n\r\n    // Another arc that won't be drawn. Just for labels positioning\r\n    var outerArc = d3.arc()\r\n        .innerRadius(radius * 0.9)\r\n        .outerRadius(radius * 0.9)\r\n\r\n    // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.\r\n    svg\r\n        .selectAll('allSlices')\r\n        .data(data_ready)\r\n        .enter()\r\n        .append('path')\r\n        .attr('d', arc)\r\n        .attr('fill', function (d) { return (color(d.data.key)) })\r\n        .attr(\"stroke\", \"white\")\r\n        .style(\"stroke-width\", \"2px\")\r\n        .style(\"opacity\", 0.7)\r\n\r\n    // Add the polylines between chart and labels:\r\n    svg\r\n        .selectAll('allPolylines')\r\n        .data(data_ready)\r\n        .enter()\r\n        .append('polyline')\r\n        .attr(\"stroke\", \"black\")\r\n        .style(\"fill\", \"none\")\r\n        .attr(\"stroke-width\", 1)\r\n        .attr('points', function (d) {\r\n            var posA = arc.centroid(d) // line insertion in the slice\r\n            var posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that\r\n            var posC = outerArc.centroid(d); // Label position = almost the same as posB\r\n            var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left\r\n            posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left\r\n            return [posA, posB, posC]\r\n        })\r\n\r\n    // Add the polylines between chart and labels:\r\n    svg\r\n        .selectAll('allLabels')\r\n        .data(data_ready)\r\n        .enter()\r\n        .append('text')\r\n        .text(function (d) { return d.data.value.label })\r\n        .attr('transform', function (d) {\r\n            var pos = outerArc.centroid(d);\r\n            var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2\r\n            pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);\r\n            return 'translate(' + pos + ')';\r\n        })\r\n        .style('text-anchor', function (d) {\r\n            var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2\r\n            return (midangle < Math.PI ? 'start' : 'end')\r\n        })\r\n}\r\nwindow.donutChart = donutChart;\r\nmodule.exports = donutChart;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kb251dENoYXJ0LmpzPzA1NmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQWlEO0FBQ3pFLEtBQUssMkNBQTJDO0FBQ2hELEtBQUsseUNBQXlDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0IsR0FBRyxvQkFBb0I7O0FBRW5GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixzQkFBc0IsRUFBRTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNkJBQTZCO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkb251dENoYXJ0ID0gKHRvdGFsQWN0aXZlLCB0b3RhbERlYXRoLCB0b3RhbFJlY292ZXJlZCkgPT4ge1xyXG4gICAgdmFyIHBpZUNoYXJQYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd29ybGRBY3RpdmVQaWVDaGFydCcpLnBhcmVudEVsZW1lbnQ7XHJcbiAgICB2YXIgcGllQ2hhcnRXaWR0aCA9IHBpZUNoYXJQYXJlbnQub2Zmc2V0V2lkdGggKiAwLjY7XHJcbiAgICB2YXIgcmFkaXVzID0gcGllQ2hhcnRXaWR0aCAvIDI7XHJcbiAgICBjb25zdCBkb251dERhdGEgPSBbeyBsYWJlbDogJ3RvdGFsUmVjb3ZlcmVkJywgdmFsdWU6IHRvdGFsUmVjb3ZlcmVkIH0sXHJcbiAgICB7IGxhYmVsOiAndG90YWxBY3RpdmUnLCB2YWx1ZTogdG90YWxBY3RpdmUgfSxcclxuICAgIHsgbGFiZWw6ICd0b3RhbERlYXRoJywgdmFsdWU6IHRvdGFsRGVhdGggfV07XHJcblxyXG4gICAgdmFyIHN2ZyA9IGQzLnNlbGVjdChcIiN3b3JsZEFjdGl2ZVBpZUNoYXJ0XCIpXHJcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBwaWVDaGFyUGFyZW50Lm9mZnNldFdpZHRoKVxyXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHBpZUNoYXJQYXJlbnQub2Zmc2V0V2lkdGggLyAxLjIpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtwaWVDaGFydFdpZHRoIC8gMS4yfSwke3BpZUNoYXJ0V2lkdGggLyAxLjJ9KWApXHJcblxyXG4gICAgdmFyIGNvbG9yID0gZDMuc2NhbGVPcmRpbmFsKClcclxuICAgICAgICAuZG9tYWluKGRvbnV0RGF0YS5tYXAoZCA9PiBkLmxhYmVsKSlcclxuICAgICAgICAucmFuZ2UoZDMuc2NoZW1lRGFyazIpO1xyXG5cclxuICAgIHZhciBwaWUgPSBkMy5waWUoKVxyXG4gICAgICAgIC52YWx1ZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZS52YWx1ZTsgfSlcclxuICAgIHZhciBkYXRhX3JlYWR5ID0gcGllKGQzLmVudHJpZXMoZG9udXREYXRhKSlcclxuXHJcbiAgICB2YXIgYXJjID0gZDMuYXJjKClcclxuICAgICAgICAuaW5uZXJSYWRpdXMocmFkaXVzICogMC41KVxyXG4gICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMgKiAwLjgpXHJcblxyXG4gICAgLy8gQW5vdGhlciBhcmMgdGhhdCB3b24ndCBiZSBkcmF3bi4gSnVzdCBmb3IgbGFiZWxzIHBvc2l0aW9uaW5nXHJcbiAgICB2YXIgb3V0ZXJBcmMgPSBkMy5hcmMoKVxyXG4gICAgICAgIC5pbm5lclJhZGl1cyhyYWRpdXMgKiAwLjkpXHJcbiAgICAgICAgLm91dGVyUmFkaXVzKHJhZGl1cyAqIDAuOSlcclxuXHJcbiAgICAvLyBCdWlsZCB0aGUgcGllIGNoYXJ0OiBCYXNpY2FsbHksIGVhY2ggcGFydCBvZiB0aGUgcGllIGlzIGEgcGF0aCB0aGF0IHdlIGJ1aWxkIHVzaW5nIHRoZSBhcmMgZnVuY3Rpb24uXHJcbiAgICBzdmdcclxuICAgICAgICAuc2VsZWN0QWxsKCdhbGxTbGljZXMnKVxyXG4gICAgICAgIC5kYXRhKGRhdGFfcmVhZHkpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAuYXR0cignZCcsIGFyYylcclxuICAgICAgICAuYXR0cignZmlsbCcsIGZ1bmN0aW9uIChkKSB7IHJldHVybiAoY29sb3IoZC5kYXRhLmtleSkpIH0pXHJcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJ3aGl0ZVwiKVxyXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCBcIjJweFwiKVxyXG4gICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMC43KVxyXG5cclxuICAgIC8vIEFkZCB0aGUgcG9seWxpbmVzIGJldHdlZW4gY2hhcnQgYW5kIGxhYmVsczpcclxuICAgIHN2Z1xyXG4gICAgICAgIC5zZWxlY3RBbGwoJ2FsbFBvbHlsaW5lcycpXHJcbiAgICAgICAgLmRhdGEoZGF0YV9yZWFkeSlcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ3BvbHlsaW5lJylcclxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcImJsYWNrXCIpXHJcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIm5vbmVcIilcclxuICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxKVxyXG4gICAgICAgIC5hdHRyKCdwb2ludHMnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgcG9zQSA9IGFyYy5jZW50cm9pZChkKSAvLyBsaW5lIGluc2VydGlvbiBpbiB0aGUgc2xpY2VcclxuICAgICAgICAgICAgdmFyIHBvc0IgPSBvdXRlckFyYy5jZW50cm9pZChkKSAvLyBsaW5lIGJyZWFrOiB3ZSB1c2UgdGhlIG90aGVyIGFyYyBnZW5lcmF0b3IgdGhhdCBoYXMgYmVlbiBidWlsdCBvbmx5IGZvciB0aGF0XHJcbiAgICAgICAgICAgIHZhciBwb3NDID0gb3V0ZXJBcmMuY2VudHJvaWQoZCk7IC8vIExhYmVsIHBvc2l0aW9uID0gYWxtb3N0IHRoZSBzYW1lIGFzIHBvc0JcclxuICAgICAgICAgICAgdmFyIG1pZGFuZ2xlID0gZC5zdGFydEFuZ2xlICsgKGQuZW5kQW5nbGUgLSBkLnN0YXJ0QW5nbGUpIC8gMiAvLyB3ZSBuZWVkIHRoZSBhbmdsZSB0byBzZWUgaWYgdGhlIFggcG9zaXRpb24gd2lsbCBiZSBhdCB0aGUgZXh0cmVtZSByaWdodCBvciBleHRyZW1lIGxlZnRcclxuICAgICAgICAgICAgcG9zQ1swXSA9IHJhZGl1cyAqIDAuOTUgKiAobWlkYW5nbGUgPCBNYXRoLlBJID8gMSA6IC0xKTsgLy8gbXVsdGlwbHkgYnkgMSBvciAtMSB0byBwdXQgaXQgb24gdGhlIHJpZ2h0IG9yIG9uIHRoZSBsZWZ0XHJcbiAgICAgICAgICAgIHJldHVybiBbcG9zQSwgcG9zQiwgcG9zQ11cclxuICAgICAgICB9KVxyXG5cclxuICAgIC8vIEFkZCB0aGUgcG9seWxpbmVzIGJldHdlZW4gY2hhcnQgYW5kIGxhYmVsczpcclxuICAgIHN2Z1xyXG4gICAgICAgIC5zZWxlY3RBbGwoJ2FsbExhYmVscycpXHJcbiAgICAgICAgLmRhdGEoZGF0YV9yZWFkeSlcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmRhdGEudmFsdWUubGFiZWwgfSlcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IG91dGVyQXJjLmNlbnRyb2lkKGQpO1xyXG4gICAgICAgICAgICB2YXIgbWlkYW5nbGUgPSBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAyXHJcbiAgICAgICAgICAgIHBvc1swXSA9IHJhZGl1cyAqIDAuOTkgKiAobWlkYW5nbGUgPCBNYXRoLlBJID8gMSA6IC0xKTtcclxuICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHBvcyArICcpJztcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgbWlkYW5nbGUgPSBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAyXHJcbiAgICAgICAgICAgIHJldHVybiAobWlkYW5nbGUgPCBNYXRoLlBJID8gJ3N0YXJ0JyA6ICdlbmQnKVxyXG4gICAgICAgIH0pXHJcbn1cclxud2luZG93LmRvbnV0Q2hhcnQgPSBkb251dENoYXJ0O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGRvbnV0Q2hhcnQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,exports){eval("const multiLineGraph = (countries, days, numberOfCountriesInLineChart) => {\r\n    var LineGraphParent = document.getElementById('worldMultilineChart').parentElement;\r\n    const margin = { left: 60, top: 30, right: 45, bottom: 20 };\r\n    countries.forEach(country => {\r\n        const option = document.createElement(\"option\");\r\n        option.value = country[0];\r\n        option.innerHTML = country[0];\r\n        countrySelection.appendChild(option);\r\n    })\r\n    const svg = d3.select('#worldMultilineChart')\r\n        .attr('width', LineGraphParent.offsetWidth)\r\n        .attr('height', LineGraphParent.offsetWidth * .4 + 20)\r\n\r\n    const g = svg.append('g')\r\n        .attr('transform', `translate(${margin.left},${margin.top})`)\r\n\r\n    //sorting country according to confirmed cases\r\n    const sortBy = document.getElementById(\"sortBy\");\r\n\r\n    const fromDayInRange = document.getElementById('fromDayInRange');\r\n    fromDayInRange.max = days;\r\n    document.getElementById('fromDay').innerHTML = fromDayInRange.value;\r\n    document.getElementById('toDay').innerHTML = days;\r\n\r\n    var fromDay = fromDayInRange.value;\r\n    countries.sort((a, b) => {\r\n        return b[1][fromDay][sortBy.value] - a[1][fromDay][sortBy.value];\r\n    })\r\n\r\n    //Graph from day X to till date\r\n    const newData = [];\r\n    countries.forEach(country => {\r\n        let name = country[0];\r\n        let data = [];\r\n        for (let i = fromDay; i < days; i++) {\r\n            data.push(country[1][i]);\r\n        }\r\n        let set = [];\r\n        set.push(name);\r\n        set.push(data);\r\n        newData.push(set);\r\n    })\r\n\r\n    var topX = [];\r\n    var numberOfCountriesInLineChart = 5;//document.getElementById('numberOfCountriesInLineChart').value;\r\n    for (let i = 0; i < numberOfCountriesInLineChart; i++) {\r\n        topX.push(newData[i]);\r\n    }\r\n\r\n    $(\"#countrySelection\").select2({\r\n        placeholder: \"Select countries\",\r\n        allowClear: true\r\n    });\r\n    const select2List = document.getElementById(\"select2-countrySelection-container\");\r\n    if (select2List.childElementCount) {\r\n        topX = [];\r\n        //select2List.children.style.color = 'black';\r\n        const select2Values = select2List.innerText.split(\"×\");\r\n        select2Values.shift();\r\n        for(let i=0;i<select2Values.length;i++){\r\n            newData.forEach(country=>{\r\n                if(country[0]===select2Values[i]){\r\n                    topX.push(country);\r\n                }\r\n            })\r\n        }\r\n        // document.getElementById(\"controlDisplay\").style.display = \"none\";\r\n    }\r\n    else {\r\n        document.getElementById(\"controlDisplay\").style.display = \"inline\";\r\n    }\r\n    var maxYValue = 0;\r\n    topX.forEach(country => {\r\n        country[1].forEach(day => {\r\n            maxYValue = maxYValue < day.confirmed ? day.confirmed : maxYValue;\r\n        })\r\n    })\r\n    //console.log(\"topX\", topX, \"newdata\", newData)\r\n    //console.log(maxYValue, topX)\r\n\r\n    const yScale = d3.scaleLinear()\r\n        .domain([maxYValue, 0])\r\n        .range([0, LineGraphParent.offsetWidth * .4 - 30])\r\n        .nice()\r\n    const yAxis = d3.axisLeft(yScale)\r\n        .tickSize(-LineGraphParent.offsetWidth + 80);\r\n    svg.selectAll('.yaxis').remove();\r\n    g.append('g')\r\n        .call(yAxis)\r\n        .attr('class', 'yaxis')\r\n        .attr('transform', `translate(${0},${-margin.bottom})`)\r\n    const lineColor = d3.scaleOrdinal().range(d3.schemeCategory10);\r\n    const line = d3.line()\r\n        .curve(d3.curveMonotoneX)\r\n        .x(d => xScale(d.date))\r\n        .y(d => yScale(d.confirmed));\r\n\r\n    const xScale = d3.scaleTime()\r\n        .domain(d3.extent(newData[0][1], d => d.date))\r\n        .range([0, LineGraphParent.offsetWidth - 80])\r\n\r\n    const xTicks = 10;\r\n    const xAxis = d3.axisBottom(xScale)\r\n        .ticks(xTicks)\r\n        .tickSize(-LineGraphParent.offsetHeight + 102);\r\n    svg.selectAll('.xaxis').remove();\r\n    g.append('g')\r\n        .call(xAxis)\r\n        .attr('class', 'xaxis')\r\n        .attr('transform', `translate(${0},${LineGraphParent.offsetWidth * .4 - margin.bottom - 30})`);\r\n\r\n    svg.selectAll(\".country\").remove();\r\n    var country = g.selectAll(\".country\")\r\n        .data(topX)\r\n        .enter()\r\n        .append(\"g\")\r\n        .attr(\"class\", d => `country ${d[0]}`)\r\n        .attr('transform', `translate(${-margin.left + 61},${-margin.bottom})`);\r\n\r\n    country.append('path')\r\n        .attr('fill', 'none')\r\n        .style(\"stroke\", d => lineColor(d[0]))\r\n        .attr(\"stroke-width\", 1.5)\r\n        .attr(\"d\", d => line(d[1]))\r\n\r\n    country.append('text')\r\n        .style(\"fill\", d => lineColor(d[0]))\r\n        .text(d => d[0])\r\n        .style(\"font-weight\", 600)\r\n        .attr('x', d => xScale(d[1][days - 1 - fromDay].date) - 80)\r\n        .attr('y', d => yScale(d[1][days - 1 - fromDay].confirmed) - 2)\r\n        .attr('class', 'line-graph-country-legend')\r\n\r\n    svg.selectAll('.legend-circle').remove();\r\n    country.selectAll('.legend-circles-path')\r\n        .data(topX)\r\n        .enter()\r\n        .append('g')\r\n        .attr('class', 'legend-circle')\r\n        .attr('fill', d => lineColor(d[0]))\r\n        .selectAll('circle')\r\n        .data(d => d[1])\r\n        .enter()\r\n        .append('circle')\r\n        .attr(\"r\", 1.5)\r\n        .attr(\"cx\", d => xScale(d.date))\r\n        .attr(\"cy\", d => yScale(d.confirmed))\r\n        .on('mouseover', function (d) {\r\n            div.style(\"display\", \"block\")\r\n            div.transition()\r\n                .duration(200)\r\n                .style(\"opacity\", 0.8);\r\n            div.html(\r\n                `<span style=\"font-size:16px\"><b>Confirmed</b>: ${d.confirmed}</span>\r\n                <br/>\r\n                <span style=\"color:black\"><b>Deaths</b>: ${d.deaths}</span>\r\n                <br/>\r\n                <span style=\"color:black\"><b>Date</b>: ${(d.date).toString().substring(0, 16)}</span>`\r\n            )\r\n                .style('left', d3.event.pageX + 10 + 'px')\r\n                .style('top', d3.event.pageY - 28 + 'px');\r\n            this.attributes[0].value = 3;\r\n            // console.log(this)\r\n        })\r\n        .on(\"mouseout\", function (d) { div.style(\"display\", \"none\"); this.attributes[0].value = 1.5; })\r\n\r\n}\r\nwindow.multiLineGraph = multiLineGraph;\r\nmodule.exports = multiLineGraph;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tdWx0aUxpbmVHcmFwaC5qcz8xOWFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsWUFBWSxHQUFHLFdBQVc7O0FBRWxFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlDQUF5QztBQUN6QyxtQkFBbUIsa0NBQWtDO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsRUFBRSxHQUFHLGVBQWU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFLEdBQUcsc0RBQXNEOztBQUVuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUMsd0NBQXdDLGtCQUFrQixHQUFHLGVBQWU7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxZQUFZO0FBQzlFO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEU7QUFDQSx5REFBeUQscUNBQXFDO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0NBQXNDLDhCQUE4QixnQ0FBZ0MsRUFBRTs7QUFFdEc7QUFDQTtBQUNBIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBtdWx0aUxpbmVHcmFwaCA9IChjb3VudHJpZXMsIGRheXMsIG51bWJlck9mQ291bnRyaWVzSW5MaW5lQ2hhcnQpID0+IHtcclxuICAgIHZhciBMaW5lR3JhcGhQYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd29ybGRNdWx0aWxpbmVDaGFydCcpLnBhcmVudEVsZW1lbnQ7XHJcbiAgICBjb25zdCBtYXJnaW4gPSB7IGxlZnQ6IDYwLCB0b3A6IDMwLCByaWdodDogNDUsIGJvdHRvbTogMjAgfTtcclxuICAgIGNvdW50cmllcy5mb3JFYWNoKGNvdW50cnkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XHJcbiAgICAgICAgb3B0aW9uLnZhbHVlID0gY291bnRyeVswXTtcclxuICAgICAgICBvcHRpb24uaW5uZXJIVE1MID0gY291bnRyeVswXTtcclxuICAgICAgICBjb3VudHJ5U2VsZWN0aW9uLmFwcGVuZENoaWxkKG9wdGlvbik7XHJcbiAgICB9KVxyXG4gICAgY29uc3Qgc3ZnID0gZDMuc2VsZWN0KCcjd29ybGRNdWx0aWxpbmVDaGFydCcpXHJcbiAgICAgICAgLmF0dHIoJ3dpZHRoJywgTGluZUdyYXBoUGFyZW50Lm9mZnNldFdpZHRoKVxyXG4gICAgICAgIC5hdHRyKCdoZWlnaHQnLCBMaW5lR3JhcGhQYXJlbnQub2Zmc2V0V2lkdGggKiAuNCArIDIwKVxyXG5cclxuICAgIGNvbnN0IGcgPSBzdmcuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgke21hcmdpbi5sZWZ0fSwke21hcmdpbi50b3B9KWApXHJcblxyXG4gICAgLy9zb3J0aW5nIGNvdW50cnkgYWNjb3JkaW5nIHRvIGNvbmZpcm1lZCBjYXNlc1xyXG4gICAgY29uc3Qgc29ydEJ5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzb3J0QnlcIik7XHJcblxyXG4gICAgY29uc3QgZnJvbURheUluUmFuZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZnJvbURheUluUmFuZ2UnKTtcclxuICAgIGZyb21EYXlJblJhbmdlLm1heCA9IGRheXM7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZnJvbURheScpLmlubmVySFRNTCA9IGZyb21EYXlJblJhbmdlLnZhbHVlO1xyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvRGF5JykuaW5uZXJIVE1MID0gZGF5cztcclxuXHJcbiAgICB2YXIgZnJvbURheSA9IGZyb21EYXlJblJhbmdlLnZhbHVlO1xyXG4gICAgY291bnRyaWVzLnNvcnQoKGEsIGIpID0+IHtcclxuICAgICAgICByZXR1cm4gYlsxXVtmcm9tRGF5XVtzb3J0QnkudmFsdWVdIC0gYVsxXVtmcm9tRGF5XVtzb3J0QnkudmFsdWVdO1xyXG4gICAgfSlcclxuXHJcbiAgICAvL0dyYXBoIGZyb20gZGF5IFggdG8gdGlsbCBkYXRlXHJcbiAgICBjb25zdCBuZXdEYXRhID0gW107XHJcbiAgICBjb3VudHJpZXMuZm9yRWFjaChjb3VudHJ5ID0+IHtcclxuICAgICAgICBsZXQgbmFtZSA9IGNvdW50cnlbMF07XHJcbiAgICAgICAgbGV0IGRhdGEgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gZnJvbURheTsgaSA8IGRheXM7IGkrKykge1xyXG4gICAgICAgICAgICBkYXRhLnB1c2goY291bnRyeVsxXVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBzZXQgPSBbXTtcclxuICAgICAgICBzZXQucHVzaChuYW1lKTtcclxuICAgICAgICBzZXQucHVzaChkYXRhKTtcclxuICAgICAgICBuZXdEYXRhLnB1c2goc2V0KTtcclxuICAgIH0pXHJcblxyXG4gICAgdmFyIHRvcFggPSBbXTtcclxuICAgIHZhciBudW1iZXJPZkNvdW50cmllc0luTGluZUNoYXJ0ID0gNTsvL2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdudW1iZXJPZkNvdW50cmllc0luTGluZUNoYXJ0JykudmFsdWU7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mQ291bnRyaWVzSW5MaW5lQ2hhcnQ7IGkrKykge1xyXG4gICAgICAgIHRvcFgucHVzaChuZXdEYXRhW2ldKTtcclxuICAgIH1cclxuXHJcbiAgICAkKFwiI2NvdW50cnlTZWxlY3Rpb25cIikuc2VsZWN0Mih7XHJcbiAgICAgICAgcGxhY2Vob2xkZXI6IFwiU2VsZWN0IGNvdW50cmllc1wiLFxyXG4gICAgICAgIGFsbG93Q2xlYXI6IHRydWVcclxuICAgIH0pO1xyXG4gICAgY29uc3Qgc2VsZWN0Mkxpc3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNlbGVjdDItY291bnRyeVNlbGVjdGlvbi1jb250YWluZXJcIik7XHJcbiAgICBpZiAoc2VsZWN0Mkxpc3QuY2hpbGRFbGVtZW50Q291bnQpIHtcclxuICAgICAgICB0b3BYID0gW107XHJcbiAgICAgICAgLy9zZWxlY3QyTGlzdC5jaGlsZHJlbi5zdHlsZS5jb2xvciA9ICdibGFjayc7XHJcbiAgICAgICAgY29uc3Qgc2VsZWN0MlZhbHVlcyA9IHNlbGVjdDJMaXN0LmlubmVyVGV4dC5zcGxpdChcIsOXXCIpO1xyXG4gICAgICAgIHNlbGVjdDJWYWx1ZXMuc2hpZnQoKTtcclxuICAgICAgICBmb3IobGV0IGk9MDtpPHNlbGVjdDJWYWx1ZXMubGVuZ3RoO2krKyl7XHJcbiAgICAgICAgICAgIG5ld0RhdGEuZm9yRWFjaChjb3VudHJ5PT57XHJcbiAgICAgICAgICAgICAgICBpZihjb3VudHJ5WzBdPT09c2VsZWN0MlZhbHVlc1tpXSl7XHJcbiAgICAgICAgICAgICAgICAgICAgdG9wWC5wdXNoKGNvdW50cnkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbnRyb2xEaXNwbGF5XCIpLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29udHJvbERpc3BsYXlcIikuc3R5bGUuZGlzcGxheSA9IFwiaW5saW5lXCI7XHJcbiAgICB9XHJcbiAgICB2YXIgbWF4WVZhbHVlID0gMDtcclxuICAgIHRvcFguZm9yRWFjaChjb3VudHJ5ID0+IHtcclxuICAgICAgICBjb3VudHJ5WzFdLmZvckVhY2goZGF5ID0+IHtcclxuICAgICAgICAgICAgbWF4WVZhbHVlID0gbWF4WVZhbHVlIDwgZGF5LmNvbmZpcm1lZCA/IGRheS5jb25maXJtZWQgOiBtYXhZVmFsdWU7XHJcbiAgICAgICAgfSlcclxuICAgIH0pXHJcbiAgICAvL2NvbnNvbGUubG9nKFwidG9wWFwiLCB0b3BYLCBcIm5ld2RhdGFcIiwgbmV3RGF0YSlcclxuICAgIC8vY29uc29sZS5sb2cobWF4WVZhbHVlLCB0b3BYKVxyXG5cclxuICAgIGNvbnN0IHlTY2FsZSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAuZG9tYWluKFttYXhZVmFsdWUsIDBdKVxyXG4gICAgICAgIC5yYW5nZShbMCwgTGluZUdyYXBoUGFyZW50Lm9mZnNldFdpZHRoICogLjQgLSAzMF0pXHJcbiAgICAgICAgLm5pY2UoKVxyXG4gICAgY29uc3QgeUF4aXMgPSBkMy5heGlzTGVmdCh5U2NhbGUpXHJcbiAgICAgICAgLnRpY2tTaXplKC1MaW5lR3JhcGhQYXJlbnQub2Zmc2V0V2lkdGggKyA4MCk7XHJcbiAgICBzdmcuc2VsZWN0QWxsKCcueWF4aXMnKS5yZW1vdmUoKTtcclxuICAgIGcuYXBwZW5kKCdnJylcclxuICAgICAgICAuY2FsbCh5QXhpcylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAneWF4aXMnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7MH0sJHstbWFyZ2luLmJvdHRvbX0pYClcclxuICAgIGNvbnN0IGxpbmVDb2xvciA9IGQzLnNjYWxlT3JkaW5hbCgpLnJhbmdlKGQzLnNjaGVtZUNhdGVnb3J5MTApO1xyXG4gICAgY29uc3QgbGluZSA9IGQzLmxpbmUoKVxyXG4gICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAueChkID0+IHhTY2FsZShkLmRhdGUpKVxyXG4gICAgICAgIC55KGQgPT4geVNjYWxlKGQuY29uZmlybWVkKSk7XHJcblxyXG4gICAgY29uc3QgeFNjYWxlID0gZDMuc2NhbGVUaW1lKClcclxuICAgICAgICAuZG9tYWluKGQzLmV4dGVudChuZXdEYXRhWzBdWzFdLCBkID0+IGQuZGF0ZSkpXHJcbiAgICAgICAgLnJhbmdlKFswLCBMaW5lR3JhcGhQYXJlbnQub2Zmc2V0V2lkdGggLSA4MF0pXHJcblxyXG4gICAgY29uc3QgeFRpY2tzID0gMTA7XHJcbiAgICBjb25zdCB4QXhpcyA9IGQzLmF4aXNCb3R0b20oeFNjYWxlKVxyXG4gICAgICAgIC50aWNrcyh4VGlja3MpXHJcbiAgICAgICAgLnRpY2tTaXplKC1MaW5lR3JhcGhQYXJlbnQub2Zmc2V0SGVpZ2h0ICsgMTAyKTtcclxuICAgIHN2Zy5zZWxlY3RBbGwoJy54YXhpcycpLnJlbW92ZSgpO1xyXG4gICAgZy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5jYWxsKHhBeGlzKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICd4YXhpcycpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHswfSwke0xpbmVHcmFwaFBhcmVudC5vZmZzZXRXaWR0aCAqIC40IC0gbWFyZ2luLmJvdHRvbSAtIDMwfSlgKTtcclxuXHJcbiAgICBzdmcuc2VsZWN0QWxsKFwiLmNvdW50cnlcIikucmVtb3ZlKCk7XHJcbiAgICB2YXIgY291bnRyeSA9IGcuc2VsZWN0QWxsKFwiLmNvdW50cnlcIilcclxuICAgICAgICAuZGF0YSh0b3BYKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZChcImdcIilcclxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIGQgPT4gYGNvdW50cnkgJHtkWzBdfWApXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHstbWFyZ2luLmxlZnQgKyA2MX0sJHstbWFyZ2luLmJvdHRvbX0pYCk7XHJcblxyXG4gICAgY291bnRyeS5hcHBlbmQoJ3BhdGgnKVxyXG4gICAgICAgIC5hdHRyKCdmaWxsJywgJ25vbmUnKVxyXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBkID0+IGxpbmVDb2xvcihkWzBdKSlcclxuICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxLjUpXHJcbiAgICAgICAgLmF0dHIoXCJkXCIsIGQgPT4gbGluZShkWzFdKSlcclxuXHJcbiAgICBjb3VudHJ5LmFwcGVuZCgndGV4dCcpXHJcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBkID0+IGxpbmVDb2xvcihkWzBdKSlcclxuICAgICAgICAudGV4dChkID0+IGRbMF0pXHJcbiAgICAgICAgLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgNjAwKVxyXG4gICAgICAgIC5hdHRyKCd4JywgZCA9PiB4U2NhbGUoZFsxXVtkYXlzIC0gMSAtIGZyb21EYXldLmRhdGUpIC0gODApXHJcbiAgICAgICAgLmF0dHIoJ3knLCBkID0+IHlTY2FsZShkWzFdW2RheXMgLSAxIC0gZnJvbURheV0uY29uZmlybWVkKSAtIDIpXHJcbiAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2xpbmUtZ3JhcGgtY291bnRyeS1sZWdlbmQnKVxyXG5cclxuICAgIHN2Zy5zZWxlY3RBbGwoJy5sZWdlbmQtY2lyY2xlJykucmVtb3ZlKCk7XHJcbiAgICBjb3VudHJ5LnNlbGVjdEFsbCgnLmxlZ2VuZC1jaXJjbGVzLXBhdGgnKVxyXG4gICAgICAgIC5kYXRhKHRvcFgpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdnJylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGVnZW5kLWNpcmNsZScpXHJcbiAgICAgICAgLmF0dHIoJ2ZpbGwnLCBkID0+IGxpbmVDb2xvcihkWzBdKSlcclxuICAgICAgICAuc2VsZWN0QWxsKCdjaXJjbGUnKVxyXG4gICAgICAgIC5kYXRhKGQgPT4gZFsxXSlcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ2NpcmNsZScpXHJcbiAgICAgICAgLmF0dHIoXCJyXCIsIDEuNSlcclxuICAgICAgICAuYXR0cihcImN4XCIsIGQgPT4geFNjYWxlKGQuZGF0ZSkpXHJcbiAgICAgICAgLmF0dHIoXCJjeVwiLCBkID0+IHlTY2FsZShkLmNvbmZpcm1lZCkpXHJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBkaXYuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIilcclxuICAgICAgICAgICAgZGl2LnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKDIwMClcclxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMC44KTtcclxuICAgICAgICAgICAgZGl2Lmh0bWwoXHJcbiAgICAgICAgICAgICAgICBgPHNwYW4gc3R5bGU9XCJmb250LXNpemU6MTZweFwiPjxiPkNvbmZpcm1lZDwvYj46ICR7ZC5jb25maXJtZWR9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPGJyLz5cclxuICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6YmxhY2tcIj48Yj5EZWF0aHM8L2I+OiAke2QuZGVhdGhzfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDxici8+XHJcbiAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOmJsYWNrXCI+PGI+RGF0ZTwvYj46ICR7KGQuZGF0ZSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTYpfTwvc3Bhbj5gXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnbGVmdCcsIGQzLmV2ZW50LnBhZ2VYICsgMTAgKyAncHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd0b3AnLCBkMy5ldmVudC5wYWdlWSAtIDI4ICsgJ3B4Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1swXS52YWx1ZSA9IDM7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMpXHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbiAoZCkgeyBkaXYuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTsgdGhpcy5hdHRyaWJ1dGVzWzBdLnZhbHVlID0gMS41OyB9KVxyXG5cclxufVxyXG53aW5kb3cubXVsdGlMaW5lR3JhcGggPSBtdWx0aUxpbmVHcmFwaDtcclxubW9kdWxlLmV4cG9ydHMgPSBtdWx0aUxpbmVHcmFwaDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")}]);