!function(t){var n={};function g(I){if(n[I])return n[I].exports;var c=n[I]={i:I,l:!1,exports:{}};return t[I].call(c.exports,c,c.exports,g),c.l=!0,c.exports}g.m=t,g.c=n,g.d=function(t,n,I){g.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:I})},g.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},g.t=function(t,n){if(1&n&&(t=g(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var I=Object.create(null);if(g.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var c in t)g.d(I,c,function(n){return t[n]}.bind(null,c));return I},g.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return g.d(n,"a",n),n},g.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},g.p="",g(g.s=0)}([function(module,exports,__webpack_require__){eval('var donutChart = __webpack_require__(1);\r\nmultiLineGraph = __webpack_require__(2);\r\n//window.multiLineGraph = multiLineGraph;\r\n\r\nconst countrySelection = document.getElementById("countrySelection");\r\nconst totalConfirmedInDoc = document.getElementById("totalConfirmed");\r\nconst totalDeathsInDoc = document.getElementById("totalDeaths");\r\nconst totalRecoveredInDoc = document.getElementById("totalRecovered");\r\nconst totalDeathRateInDoc = document.getElementById("deathRate");\r\nconst totalRecoveryRateInDoc = document.getElementById("recoveryRate");\r\nconst worldTable = document.getElementById("worldTable");\r\n\r\ncountries = {};\r\nwindow.days = 0;\r\n//Tool tip div element\r\ndiv = d3\r\n    .select(\'body\')\r\n    .append(\'div\')\r\n    .attr(\'class\', \'tooltip\')\r\n\r\nconst fetchData = async () => {\r\n    const data = await fetch(\'https://pomber.github.io/covid19/timeseries.json\');\r\n    const jsonData = await data.json();\r\n\r\n    countries = Object.keys(jsonData).map((country) => {\r\n        return [country, jsonData[country]]\r\n    })\r\n    //parsing date\r\n    var parseDate = d3.timeParse("%Y-%m-%d");\r\n    countries.forEach(country => {\r\n        country[1].forEach(day => {\r\n            day.date = parseDate(day.date)\r\n        })\r\n    })\r\n\r\n    days = countries[0][1].length;\r\n\r\n    //add countrySelection\r\n    let totalConfirmed = 0;\r\n    let totalDeath = 0;\r\n    let totalRecovered = 0;\r\n    let totalConfirmedChange = 0;\r\n    let totalDeathChange = 0;\r\n    let totalRecoveredChange = 0;\r\n    let countryWithHighestDeathRate = 0;\r\n\r\n    countries.forEach(country => {\r\n        const days = country[1].length;\r\n        totalConfirmed += country[1][days - 1].confirmed;\r\n        totalConfirmedChange += country[1][days - 2].confirmed\r\n        totalRecovered += country[1][days - 1].recovered;\r\n        totalRecoveredChange += country[1][days - 2].recovered;\r\n        totalDeath += country[1][days - 1].deaths;\r\n        totalDeathChange += country[1][days - 2].deaths;\r\n        countryWithHighestDeathRate = countryWithHighestDeathRate > (country[1][days - 2].deaths / country[1][days - 2].confirmed) * 100 ? countryWithHighestDeathRate : (country[1][days - 2].deaths / country[1][days - 2].confirmed) * 100;\r\n    })\r\n\r\n    let totalActive = totalConfirmed - totalDeath - totalRecovered;\r\n    totalConfirmedInDoc.innerHTML = totalConfirmed + `<span class="change"> (${totalConfirmed - totalConfirmedChange}+)</span>`;\r\n    totalDeathsInDoc.innerHTML = totalDeath + `<span class="change"> (${totalDeath - totalDeathChange}+)</span>`;\r\n    totalRecoveredInDoc.innerHTML = totalRecovered + `<span class="change"> (${totalRecovered - totalRecoveredChange}+)</span>`;\r\n    let totalDeathRate = Math.floor((totalDeath * 100 / totalConfirmed) * 100) / 100;\r\n    totalDeathRateInDoc.innerHTML = totalDeathRate + "%";\r\n    let totalRecoveryRate = Math.floor((totalRecovered * 100 / totalConfirmed) * 100) / 100;\r\n    totalRecoveryRateInDoc.innerHTML = totalRecoveryRate + "%";\r\n\r\n    //--------Adding Donut char for whole wold data---------\r\n    donutChart(totalActive, totalDeath, totalRecovered);\r\n\r\n    //--------Adding Multiline Graph------------------------\r\n    multiLineGraph(countries, days, numberOfCountriesInLineChart);\r\n\r\n    //--------Table making----------------------------------\r\n    countries.forEach((country, index) => {\r\n        let TR = document.createElement("tr");\r\n        let TDcountry = document.createElement("td");\r\n        let TDcases = document.createElement("td");\r\n        let TDdeath = document.createElement("td");\r\n        let TDdeathrate = document.createElement("td");\r\n        let countryDeathRate = ((country[1][days - 1].deaths * 100) / country[1][days - 1].confirmed).toFixed(1);\r\n        if (countryDeathRate < 10) {\r\n            countryDeathRate = ". " + countryDeathRate;\r\n        }\r\n        let barWidth = (((country[1][days - 1].deaths / country[1][days - 1].confirmed) * 100) / countryWithHighestDeathRate) * 150;\r\n        let deathRateBar = `<svg width="100" height="20">\r\n            <rect width=${barWidth} height="20" fill="brown"></rect>\r\n        </svg>`\r\n        TDcountry.innerHTML = `${country[0]}`;\r\n        TDcases.innerHTML = country[1][days - 1].confirmed;\r\n        TDdeath.innerHTML = country[1][days - 1].deaths;\r\n        TDdeathrate.innerHTML = countryDeathRate + "% " + deathRateBar;\r\n        TR.append(TDcountry, TDcases, TDdeath, TDdeathrate)\r\n        worldTable.appendChild(TR);\r\n    })\r\n\r\n}\r\nfetchData()\r\n\r\n///////////filter in table\r\nwindow.searchCountry = () => {\r\n    var input, filter, table, tr, td, i, txtValue;\r\n    input = document.getElementById("tableSearchInput");\r\n    filter = input.value.toUpperCase();\r\n    table = worldTable.parentNode;\r\n    tr = table.getElementsByTagName("tr");\r\n    for (i = 0; i < tr.length; i++) {\r\n        td = tr[i].getElementsByTagName("td")[0];\r\n        if (td) {\r\n            txtValue = td.textContent || td.innerText;\r\n            if (txtValue.toUpperCase().indexOf(filter) > -1) {\r\n                tr[i].style.display = "";\r\n            } else {\r\n                tr[i].style.display = "none";\r\n            }\r\n        }\r\n    }\r\n}\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zY3JpcHQuanM/ZjdhNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxDQUFjO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLENBQWtCO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSwrRUFBK0Usc0NBQXNDO0FBQ3JILHdFQUF3RSw4QkFBOEI7QUFDdEcsK0VBQStFLHNDQUFzQztBQUNySDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsU0FBUztBQUNuQztBQUNBLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZG9udXRDaGFydCA9IHJlcXVpcmUoJy4vZG9udXRDaGFydCcpO1xyXG5tdWx0aUxpbmVHcmFwaCA9IHJlcXVpcmUoJy4vbXVsdGlMaW5lR3JhcGgnKTtcclxuLy93aW5kb3cubXVsdGlMaW5lR3JhcGggPSBtdWx0aUxpbmVHcmFwaDtcclxuXHJcbmNvbnN0IGNvdW50cnlTZWxlY3Rpb24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvdW50cnlTZWxlY3Rpb25cIik7XHJcbmNvbnN0IHRvdGFsQ29uZmlybWVkSW5Eb2MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRvdGFsQ29uZmlybWVkXCIpO1xyXG5jb25zdCB0b3RhbERlYXRoc0luRG9jID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0b3RhbERlYXRoc1wiKTtcclxuY29uc3QgdG90YWxSZWNvdmVyZWRJbkRvYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidG90YWxSZWNvdmVyZWRcIik7XHJcbmNvbnN0IHRvdGFsRGVhdGhSYXRlSW5Eb2MgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlYXRoUmF0ZVwiKTtcclxuY29uc3QgdG90YWxSZWNvdmVyeVJhdGVJbkRvYyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicmVjb3ZlcnlSYXRlXCIpO1xyXG5jb25zdCB3b3JsZFRhYmxlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ3b3JsZFRhYmxlXCIpO1xyXG5cclxuY291bnRyaWVzID0ge307XHJcbndpbmRvdy5kYXlzID0gMDtcclxuLy9Ub29sIHRpcCBkaXYgZWxlbWVudFxyXG5kaXYgPSBkM1xyXG4gICAgLnNlbGVjdCgnYm9keScpXHJcbiAgICAuYXBwZW5kKCdkaXYnKVxyXG4gICAgLmF0dHIoJ2NsYXNzJywgJ3Rvb2x0aXAnKVxyXG5cclxuY29uc3QgZmV0Y2hEYXRhID0gYXN5bmMgKCkgPT4ge1xyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoKCdodHRwczovL3BvbWJlci5naXRodWIuaW8vY292aWQxOS90aW1lc2VyaWVzLmpzb24nKTtcclxuICAgIGNvbnN0IGpzb25EYXRhID0gYXdhaXQgZGF0YS5qc29uKCk7XHJcblxyXG4gICAgY291bnRyaWVzID0gT2JqZWN0LmtleXMoanNvbkRhdGEpLm1hcCgoY291bnRyeSkgPT4ge1xyXG4gICAgICAgIHJldHVybiBbY291bnRyeSwganNvbkRhdGFbY291bnRyeV1dXHJcbiAgICB9KVxyXG4gICAgLy9wYXJzaW5nIGRhdGVcclxuICAgIHZhciBwYXJzZURhdGUgPSBkMy50aW1lUGFyc2UoXCIlWS0lbS0lZFwiKTtcclxuICAgIGNvdW50cmllcy5mb3JFYWNoKGNvdW50cnkgPT4ge1xyXG4gICAgICAgIGNvdW50cnlbMV0uZm9yRWFjaChkYXkgPT4ge1xyXG4gICAgICAgICAgICBkYXkuZGF0ZSA9IHBhcnNlRGF0ZShkYXkuZGF0ZSlcclxuICAgICAgICB9KVxyXG4gICAgfSlcclxuXHJcbiAgICBkYXlzID0gY291bnRyaWVzWzBdWzFdLmxlbmd0aDtcclxuXHJcbiAgICAvL2FkZCBjb3VudHJ5U2VsZWN0aW9uXHJcbiAgICBsZXQgdG90YWxDb25maXJtZWQgPSAwO1xyXG4gICAgbGV0IHRvdGFsRGVhdGggPSAwO1xyXG4gICAgbGV0IHRvdGFsUmVjb3ZlcmVkID0gMDtcclxuICAgIGxldCB0b3RhbENvbmZpcm1lZENoYW5nZSA9IDA7XHJcbiAgICBsZXQgdG90YWxEZWF0aENoYW5nZSA9IDA7XHJcbiAgICBsZXQgdG90YWxSZWNvdmVyZWRDaGFuZ2UgPSAwO1xyXG4gICAgbGV0IGNvdW50cnlXaXRoSGlnaGVzdERlYXRoUmF0ZSA9IDA7XHJcblxyXG4gICAgY291bnRyaWVzLmZvckVhY2goY291bnRyeSA9PiB7XHJcbiAgICAgICAgY29uc3QgZGF5cyA9IGNvdW50cnlbMV0ubGVuZ3RoO1xyXG4gICAgICAgIHRvdGFsQ29uZmlybWVkICs9IGNvdW50cnlbMV1bZGF5cyAtIDFdLmNvbmZpcm1lZDtcclxuICAgICAgICB0b3RhbENvbmZpcm1lZENoYW5nZSArPSBjb3VudHJ5WzFdW2RheXMgLSAyXS5jb25maXJtZWRcclxuICAgICAgICB0b3RhbFJlY292ZXJlZCArPSBjb3VudHJ5WzFdW2RheXMgLSAxXS5yZWNvdmVyZWQ7XHJcbiAgICAgICAgdG90YWxSZWNvdmVyZWRDaGFuZ2UgKz0gY291bnRyeVsxXVtkYXlzIC0gMl0ucmVjb3ZlcmVkO1xyXG4gICAgICAgIHRvdGFsRGVhdGggKz0gY291bnRyeVsxXVtkYXlzIC0gMV0uZGVhdGhzO1xyXG4gICAgICAgIHRvdGFsRGVhdGhDaGFuZ2UgKz0gY291bnRyeVsxXVtkYXlzIC0gMl0uZGVhdGhzO1xyXG4gICAgICAgIGNvdW50cnlXaXRoSGlnaGVzdERlYXRoUmF0ZSA9IGNvdW50cnlXaXRoSGlnaGVzdERlYXRoUmF0ZSA+IChjb3VudHJ5WzFdW2RheXMgLSAyXS5kZWF0aHMgLyBjb3VudHJ5WzFdW2RheXMgLSAyXS5jb25maXJtZWQpICogMTAwID8gY291bnRyeVdpdGhIaWdoZXN0RGVhdGhSYXRlIDogKGNvdW50cnlbMV1bZGF5cyAtIDJdLmRlYXRocyAvIGNvdW50cnlbMV1bZGF5cyAtIDJdLmNvbmZpcm1lZCkgKiAxMDA7XHJcbiAgICB9KVxyXG5cclxuICAgIGxldCB0b3RhbEFjdGl2ZSA9IHRvdGFsQ29uZmlybWVkIC0gdG90YWxEZWF0aCAtIHRvdGFsUmVjb3ZlcmVkO1xyXG4gICAgdG90YWxDb25maXJtZWRJbkRvYy5pbm5lckhUTUwgPSB0b3RhbENvbmZpcm1lZCArIGA8c3BhbiBjbGFzcz1cImNoYW5nZVwiPiAoJHt0b3RhbENvbmZpcm1lZCAtIHRvdGFsQ29uZmlybWVkQ2hhbmdlfSspPC9zcGFuPmA7XHJcbiAgICB0b3RhbERlYXRoc0luRG9jLmlubmVySFRNTCA9IHRvdGFsRGVhdGggKyBgPHNwYW4gY2xhc3M9XCJjaGFuZ2VcIj4gKCR7dG90YWxEZWF0aCAtIHRvdGFsRGVhdGhDaGFuZ2V9Kyk8L3NwYW4+YDtcclxuICAgIHRvdGFsUmVjb3ZlcmVkSW5Eb2MuaW5uZXJIVE1MID0gdG90YWxSZWNvdmVyZWQgKyBgPHNwYW4gY2xhc3M9XCJjaGFuZ2VcIj4gKCR7dG90YWxSZWNvdmVyZWQgLSB0b3RhbFJlY292ZXJlZENoYW5nZX0rKTwvc3Bhbj5gO1xyXG4gICAgbGV0IHRvdGFsRGVhdGhSYXRlID0gTWF0aC5mbG9vcigodG90YWxEZWF0aCAqIDEwMCAvIHRvdGFsQ29uZmlybWVkKSAqIDEwMCkgLyAxMDA7XHJcbiAgICB0b3RhbERlYXRoUmF0ZUluRG9jLmlubmVySFRNTCA9IHRvdGFsRGVhdGhSYXRlICsgXCIlXCI7XHJcbiAgICBsZXQgdG90YWxSZWNvdmVyeVJhdGUgPSBNYXRoLmZsb29yKCh0b3RhbFJlY292ZXJlZCAqIDEwMCAvIHRvdGFsQ29uZmlybWVkKSAqIDEwMCkgLyAxMDA7XHJcbiAgICB0b3RhbFJlY292ZXJ5UmF0ZUluRG9jLmlubmVySFRNTCA9IHRvdGFsUmVjb3ZlcnlSYXRlICsgXCIlXCI7XHJcblxyXG4gICAgLy8tLS0tLS0tLUFkZGluZyBEb251dCBjaGFyIGZvciB3aG9sZSB3b2xkIGRhdGEtLS0tLS0tLS1cclxuICAgIGRvbnV0Q2hhcnQodG90YWxBY3RpdmUsIHRvdGFsRGVhdGgsIHRvdGFsUmVjb3ZlcmVkKTtcclxuXHJcbiAgICAvLy0tLS0tLS0tQWRkaW5nIE11bHRpbGluZSBHcmFwaC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgbXVsdGlMaW5lR3JhcGgoY291bnRyaWVzLCBkYXlzLCBudW1iZXJPZkNvdW50cmllc0luTGluZUNoYXJ0KTtcclxuXHJcbiAgICAvLy0tLS0tLS0tVGFibGUgbWFraW5nLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgY291bnRyaWVzLmZvckVhY2goKGNvdW50cnksIGluZGV4KSA9PiB7XHJcbiAgICAgICAgbGV0IFRSID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRyXCIpO1xyXG4gICAgICAgIGxldCBURGNvdW50cnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XHJcbiAgICAgICAgbGV0IFREY2FzZXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XHJcbiAgICAgICAgbGV0IFREZGVhdGggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XHJcbiAgICAgICAgbGV0IFREZGVhdGhyYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xyXG4gICAgICAgIGxldCBjb3VudHJ5RGVhdGhSYXRlID0gKChjb3VudHJ5WzFdW2RheXMgLSAxXS5kZWF0aHMgKiAxMDApIC8gY291bnRyeVsxXVtkYXlzIC0gMV0uY29uZmlybWVkKS50b0ZpeGVkKDEpO1xyXG4gICAgICAgIGlmIChjb3VudHJ5RGVhdGhSYXRlIDwgMTApIHtcclxuICAgICAgICAgICAgY291bnRyeURlYXRoUmF0ZSA9IFwiLiBcIiArIGNvdW50cnlEZWF0aFJhdGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBiYXJXaWR0aCA9ICgoKGNvdW50cnlbMV1bZGF5cyAtIDFdLmRlYXRocyAvIGNvdW50cnlbMV1bZGF5cyAtIDFdLmNvbmZpcm1lZCkgKiAxMDApIC8gY291bnRyeVdpdGhIaWdoZXN0RGVhdGhSYXRlKSAqIDE1MDtcclxuICAgICAgICBsZXQgZGVhdGhSYXRlQmFyID0gYDxzdmcgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIyMFwiPlxyXG4gICAgICAgICAgICA8cmVjdCB3aWR0aD0ke2JhcldpZHRofSBoZWlnaHQ9XCIyMFwiIGZpbGw9XCJicm93blwiPjwvcmVjdD5cclxuICAgICAgICA8L3N2Zz5gXHJcbiAgICAgICAgVERjb3VudHJ5LmlubmVySFRNTCA9IGAke2NvdW50cnlbMF19YDtcclxuICAgICAgICBURGNhc2VzLmlubmVySFRNTCA9IGNvdW50cnlbMV1bZGF5cyAtIDFdLmNvbmZpcm1lZDtcclxuICAgICAgICBURGRlYXRoLmlubmVySFRNTCA9IGNvdW50cnlbMV1bZGF5cyAtIDFdLmRlYXRocztcclxuICAgICAgICBURGRlYXRocmF0ZS5pbm5lckhUTUwgPSBjb3VudHJ5RGVhdGhSYXRlICsgXCIlIFwiICsgZGVhdGhSYXRlQmFyO1xyXG4gICAgICAgIFRSLmFwcGVuZChURGNvdW50cnksIFREY2FzZXMsIFREZGVhdGgsIFREZGVhdGhyYXRlKVxyXG4gICAgICAgIHdvcmxkVGFibGUuYXBwZW5kQ2hpbGQoVFIpO1xyXG4gICAgfSlcclxuXHJcbn1cclxuZmV0Y2hEYXRhKClcclxuXHJcbi8vLy8vLy8vLy8vZmlsdGVyIGluIHRhYmxlXHJcbndpbmRvdy5zZWFyY2hDb3VudHJ5ID0gKCkgPT4ge1xyXG4gICAgdmFyIGlucHV0LCBmaWx0ZXIsIHRhYmxlLCB0ciwgdGQsIGksIHR4dFZhbHVlO1xyXG4gICAgaW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRhYmxlU2VhcmNoSW5wdXRcIik7XHJcbiAgICBmaWx0ZXIgPSBpbnB1dC52YWx1ZS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgdGFibGUgPSB3b3JsZFRhYmxlLnBhcmVudE5vZGU7XHJcbiAgICB0ciA9IHRhYmxlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidHJcIik7XHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHIubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB0ZCA9IHRyW2ldLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwidGRcIilbMF07XHJcbiAgICAgICAgaWYgKHRkKSB7XHJcbiAgICAgICAgICAgIHR4dFZhbHVlID0gdGQudGV4dENvbnRlbnQgfHwgdGQuaW5uZXJUZXh0O1xyXG4gICAgICAgICAgICBpZiAodHh0VmFsdWUudG9VcHBlckNhc2UoKS5pbmRleE9mKGZpbHRlcikgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgdHJbaV0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0cltpXS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')},function(module,exports){eval("const donutChart = (totalActive, totalDeath, totalRecovered) => {\r\n    var pieCharParent = document.getElementById('worldActivePieChart').parentElement;\r\n    var pieChartWidth = pieCharParent.offsetWidth * 0.6;\r\n    var radius = pieChartWidth / 2;\r\n    const donutData = [{ label: 'totalRecovered', value: totalRecovered },\r\n    { label: 'totalActive', value: totalActive },\r\n    { label: 'totalDeath', value: totalDeath }];\r\n\r\n    var svg = d3.select(\"#worldActivePieChart\")\r\n        .attr(\"width\", pieCharParent.offsetWidth)\r\n        .attr(\"height\", pieCharParent.offsetWidth / 1.2)\r\n        .append('g')\r\n        .attr('transform', `translate(${pieChartWidth / 1.2},${pieChartWidth / 1.2})`)\r\n\r\n    var color = d3.scaleOrdinal()\r\n        .domain(donutData.map(d => d.label))\r\n        .range(d3.schemeDark2);\r\n\r\n    var pie = d3.pie()\r\n        .value(function (d) { return d.value.value; })\r\n    var data_ready = pie(d3.entries(donutData))\r\n\r\n    var arc = d3.arc()\r\n        .innerRadius(radius * 0.5)\r\n        .outerRadius(radius * 0.8)\r\n\r\n    // Another arc that won't be drawn. Just for labels positioning\r\n    var outerArc = d3.arc()\r\n        .innerRadius(radius * 0.9)\r\n        .outerRadius(radius * 0.9)\r\n\r\n    // Build the pie chart: Basically, each part of the pie is a path that we build using the arc function.\r\n    svg\r\n        .selectAll('allSlices')\r\n        .data(data_ready)\r\n        .enter()\r\n        .append('path')\r\n        .attr('d', arc)\r\n        .attr('fill', function (d) { return (color(d.data.key)) })\r\n        .attr(\"stroke\", \"white\")\r\n        .style(\"stroke-width\", \"2px\")\r\n        .style(\"opacity\", 0.7)\r\n\r\n    // Add the polylines between chart and labels:\r\n    svg\r\n        .selectAll('allPolylines')\r\n        .data(data_ready)\r\n        .enter()\r\n        .append('polyline')\r\n        .attr(\"stroke\", \"black\")\r\n        .style(\"fill\", \"none\")\r\n        .attr(\"stroke-width\", 1)\r\n        .attr('points', function (d) {\r\n            var posA = arc.centroid(d) // line insertion in the slice\r\n            var posB = outerArc.centroid(d) // line break: we use the other arc generator that has been built only for that\r\n            var posC = outerArc.centroid(d); // Label position = almost the same as posB\r\n            var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2 // we need the angle to see if the X position will be at the extreme right or extreme left\r\n            posC[0] = radius * 0.95 * (midangle < Math.PI ? 1 : -1); // multiply by 1 or -1 to put it on the right or on the left\r\n            return [posA, posB, posC]\r\n        })\r\n\r\n    // Add the polylines between chart and labels:\r\n    svg\r\n        .selectAll('allLabels')\r\n        .data(data_ready)\r\n        .enter()\r\n        .append('text')\r\n        .text(function (d) { return d.data.value.label })\r\n        .attr('transform', function (d) {\r\n            var pos = outerArc.centroid(d);\r\n            var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2\r\n            pos[0] = radius * 0.99 * (midangle < Math.PI ? 1 : -1);\r\n            return 'translate(' + pos + ')';\r\n        })\r\n        .style('text-anchor', function (d) {\r\n            var midangle = d.startAngle + (d.endAngle - d.startAngle) / 2\r\n            return (midangle < Math.PI ? 'start' : 'end')\r\n        })\r\n}\r\nwindow.donutChart = donutChart;\r\nmodule.exports = donutChart;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9kb251dENoYXJ0LmpzPzA1NmMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaURBQWlEO0FBQ3pFLEtBQUssMkNBQTJDO0FBQ2hELEtBQUsseUNBQXlDOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxvQkFBb0IsR0FBRyxvQkFBb0I7O0FBRW5GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixzQkFBc0IsRUFBRTtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNkJBQTZCO0FBQ2pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBkb251dENoYXJ0ID0gKHRvdGFsQWN0aXZlLCB0b3RhbERlYXRoLCB0b3RhbFJlY292ZXJlZCkgPT4ge1xyXG4gICAgdmFyIHBpZUNoYXJQYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd29ybGRBY3RpdmVQaWVDaGFydCcpLnBhcmVudEVsZW1lbnQ7XHJcbiAgICB2YXIgcGllQ2hhcnRXaWR0aCA9IHBpZUNoYXJQYXJlbnQub2Zmc2V0V2lkdGggKiAwLjY7XHJcbiAgICB2YXIgcmFkaXVzID0gcGllQ2hhcnRXaWR0aCAvIDI7XHJcbiAgICBjb25zdCBkb251dERhdGEgPSBbeyBsYWJlbDogJ3RvdGFsUmVjb3ZlcmVkJywgdmFsdWU6IHRvdGFsUmVjb3ZlcmVkIH0sXHJcbiAgICB7IGxhYmVsOiAndG90YWxBY3RpdmUnLCB2YWx1ZTogdG90YWxBY3RpdmUgfSxcclxuICAgIHsgbGFiZWw6ICd0b3RhbERlYXRoJywgdmFsdWU6IHRvdGFsRGVhdGggfV07XHJcblxyXG4gICAgdmFyIHN2ZyA9IGQzLnNlbGVjdChcIiN3b3JsZEFjdGl2ZVBpZUNoYXJ0XCIpXHJcbiAgICAgICAgLmF0dHIoXCJ3aWR0aFwiLCBwaWVDaGFyUGFyZW50Lm9mZnNldFdpZHRoKVxyXG4gICAgICAgIC5hdHRyKFwiaGVpZ2h0XCIsIHBpZUNoYXJQYXJlbnQub2Zmc2V0V2lkdGggLyAxLjIpXHJcbiAgICAgICAgLmFwcGVuZCgnZycpXHJcbiAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtwaWVDaGFydFdpZHRoIC8gMS4yfSwke3BpZUNoYXJ0V2lkdGggLyAxLjJ9KWApXHJcblxyXG4gICAgdmFyIGNvbG9yID0gZDMuc2NhbGVPcmRpbmFsKClcclxuICAgICAgICAuZG9tYWluKGRvbnV0RGF0YS5tYXAoZCA9PiBkLmxhYmVsKSlcclxuICAgICAgICAucmFuZ2UoZDMuc2NoZW1lRGFyazIpO1xyXG5cclxuICAgIHZhciBwaWUgPSBkMy5waWUoKVxyXG4gICAgICAgIC52YWx1ZShmdW5jdGlvbiAoZCkgeyByZXR1cm4gZC52YWx1ZS52YWx1ZTsgfSlcclxuICAgIHZhciBkYXRhX3JlYWR5ID0gcGllKGQzLmVudHJpZXMoZG9udXREYXRhKSlcclxuXHJcbiAgICB2YXIgYXJjID0gZDMuYXJjKClcclxuICAgICAgICAuaW5uZXJSYWRpdXMocmFkaXVzICogMC41KVxyXG4gICAgICAgIC5vdXRlclJhZGl1cyhyYWRpdXMgKiAwLjgpXHJcblxyXG4gICAgLy8gQW5vdGhlciBhcmMgdGhhdCB3b24ndCBiZSBkcmF3bi4gSnVzdCBmb3IgbGFiZWxzIHBvc2l0aW9uaW5nXHJcbiAgICB2YXIgb3V0ZXJBcmMgPSBkMy5hcmMoKVxyXG4gICAgICAgIC5pbm5lclJhZGl1cyhyYWRpdXMgKiAwLjkpXHJcbiAgICAgICAgLm91dGVyUmFkaXVzKHJhZGl1cyAqIDAuOSlcclxuXHJcbiAgICAvLyBCdWlsZCB0aGUgcGllIGNoYXJ0OiBCYXNpY2FsbHksIGVhY2ggcGFydCBvZiB0aGUgcGllIGlzIGEgcGF0aCB0aGF0IHdlIGJ1aWxkIHVzaW5nIHRoZSBhcmMgZnVuY3Rpb24uXHJcbiAgICBzdmdcclxuICAgICAgICAuc2VsZWN0QWxsKCdhbGxTbGljZXMnKVxyXG4gICAgICAgIC5kYXRhKGRhdGFfcmVhZHkpXHJcbiAgICAgICAgLmVudGVyKClcclxuICAgICAgICAuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAuYXR0cignZCcsIGFyYylcclxuICAgICAgICAuYXR0cignZmlsbCcsIGZ1bmN0aW9uIChkKSB7IHJldHVybiAoY29sb3IoZC5kYXRhLmtleSkpIH0pXHJcbiAgICAgICAgLmF0dHIoXCJzdHJva2VcIiwgXCJ3aGl0ZVwiKVxyXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCBcIjJweFwiKVxyXG4gICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMC43KVxyXG5cclxuICAgIC8vIEFkZCB0aGUgcG9seWxpbmVzIGJldHdlZW4gY2hhcnQgYW5kIGxhYmVsczpcclxuICAgIHN2Z1xyXG4gICAgICAgIC5zZWxlY3RBbGwoJ2FsbFBvbHlsaW5lcycpXHJcbiAgICAgICAgLmRhdGEoZGF0YV9yZWFkeSlcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ3BvbHlsaW5lJylcclxuICAgICAgICAuYXR0cihcInN0cm9rZVwiLCBcImJsYWNrXCIpXHJcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcIm5vbmVcIilcclxuICAgICAgICAuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxKVxyXG4gICAgICAgIC5hdHRyKCdwb2ludHMnLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgcG9zQSA9IGFyYy5jZW50cm9pZChkKSAvLyBsaW5lIGluc2VydGlvbiBpbiB0aGUgc2xpY2VcclxuICAgICAgICAgICAgdmFyIHBvc0IgPSBvdXRlckFyYy5jZW50cm9pZChkKSAvLyBsaW5lIGJyZWFrOiB3ZSB1c2UgdGhlIG90aGVyIGFyYyBnZW5lcmF0b3IgdGhhdCBoYXMgYmVlbiBidWlsdCBvbmx5IGZvciB0aGF0XHJcbiAgICAgICAgICAgIHZhciBwb3NDID0gb3V0ZXJBcmMuY2VudHJvaWQoZCk7IC8vIExhYmVsIHBvc2l0aW9uID0gYWxtb3N0IHRoZSBzYW1lIGFzIHBvc0JcclxuICAgICAgICAgICAgdmFyIG1pZGFuZ2xlID0gZC5zdGFydEFuZ2xlICsgKGQuZW5kQW5nbGUgLSBkLnN0YXJ0QW5nbGUpIC8gMiAvLyB3ZSBuZWVkIHRoZSBhbmdsZSB0byBzZWUgaWYgdGhlIFggcG9zaXRpb24gd2lsbCBiZSBhdCB0aGUgZXh0cmVtZSByaWdodCBvciBleHRyZW1lIGxlZnRcclxuICAgICAgICAgICAgcG9zQ1swXSA9IHJhZGl1cyAqIDAuOTUgKiAobWlkYW5nbGUgPCBNYXRoLlBJID8gMSA6IC0xKTsgLy8gbXVsdGlwbHkgYnkgMSBvciAtMSB0byBwdXQgaXQgb24gdGhlIHJpZ2h0IG9yIG9uIHRoZSBsZWZ0XHJcbiAgICAgICAgICAgIHJldHVybiBbcG9zQSwgcG9zQiwgcG9zQ11cclxuICAgICAgICB9KVxyXG5cclxuICAgIC8vIEFkZCB0aGUgcG9seWxpbmVzIGJldHdlZW4gY2hhcnQgYW5kIGxhYmVsczpcclxuICAgIHN2Z1xyXG4gICAgICAgIC5zZWxlY3RBbGwoJ2FsbExhYmVscycpXHJcbiAgICAgICAgLmRhdGEoZGF0YV9yZWFkeSlcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC50ZXh0KGZ1bmN0aW9uIChkKSB7IHJldHVybiBkLmRhdGEudmFsdWUubGFiZWwgfSlcclxuICAgICAgICAuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIHBvcyA9IG91dGVyQXJjLmNlbnRyb2lkKGQpO1xyXG4gICAgICAgICAgICB2YXIgbWlkYW5nbGUgPSBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAyXHJcbiAgICAgICAgICAgIHBvc1swXSA9IHJhZGl1cyAqIDAuOTkgKiAobWlkYW5nbGUgPCBNYXRoLlBJID8gMSA6IC0xKTtcclxuICAgICAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHBvcyArICcpJztcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5zdHlsZSgndGV4dC1hbmNob3InLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgbWlkYW5nbGUgPSBkLnN0YXJ0QW5nbGUgKyAoZC5lbmRBbmdsZSAtIGQuc3RhcnRBbmdsZSkgLyAyXHJcbiAgICAgICAgICAgIHJldHVybiAobWlkYW5nbGUgPCBNYXRoLlBJID8gJ3N0YXJ0JyA6ICdlbmQnKVxyXG4gICAgICAgIH0pXHJcbn1cclxud2luZG93LmRvbnV0Q2hhcnQgPSBkb251dENoYXJ0O1xyXG5tb2R1bGUuZXhwb3J0cyA9IGRvbnV0Q2hhcnQ7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,exports){eval("const multiLineGraph = (countries, days, numberOfCountriesInLineChart) => {\r\n    var LineGraphParent = document.getElementById('worldMultilineChart').parentElement;\r\n    const margin = { left: 60, top: 30, right: 45, bottom: 20 };\r\n    countries.forEach(country => {\r\n        const option = document.createElement(\"option\");\r\n        option.value = country[0];\r\n        option.innerHTML = country[0];\r\n        countrySelection.appendChild(option);\r\n    })\r\n    const svg = d3.select('#worldMultilineChart')\r\n        .attr('width', LineGraphParent.offsetWidth)\r\n        .attr('height', LineGraphParent.offsetWidth * .4 + 20)\r\n\r\n    const g = svg.append('g')\r\n        .attr('transform', `translate(${margin.left},${margin.top})`)\r\n\r\n    //sorting country according to confirmed cases\r\n    const sortBy = document.getElementById(\"sortBy\");\r\n\r\n    const fromDayInRange = document.getElementById('fromDayInRange');\r\n    fromDayInRange.max = days;\r\n    document.getElementById('fromDay').innerHTML = fromDayInRange.value;\r\n    document.getElementById('toDay').innerHTML = days;\r\n\r\n    var fromDay = fromDayInRange.value;\r\n    countries.sort((a, b) => {\r\n        return b[1][fromDay][sortBy.value] - a[1][fromDay][sortBy.value];\r\n    })\r\n\r\n    //Graph from day X to till date\r\n    const newData = [];\r\n    countries.forEach(country => {\r\n        let name = country[0];\r\n        let data = [];\r\n        for (let i = fromDay; i < days; i++) {\r\n            data.push(country[1][i]);\r\n        }\r\n        let set = [];\r\n        set.push(name);\r\n        set.push(data);\r\n        newData.push(set);\r\n    })\r\n\r\n    var topX = [];\r\n    var numberOfCountriesInLineChart = 5;//document.getElementById('numberOfCountriesInLineChart').value;\r\n    for (let i = 0; i < numberOfCountriesInLineChart; i++) {\r\n        topX.push(newData[i]);\r\n    }\r\n\r\n    $(\"#countrySelection\").select2({\r\n        placeholder: \"Select countries\",\r\n        allowClear: true\r\n    });\r\n    const select2List = document.getElementById(\"select2-countrySelection-container\");\r\n    if (select2List.childElementCount) {\r\n        topX = [];\r\n        //select2List.children.style.color = 'black';\r\n        const select2Values = select2List.innerText.split(\"×\");\r\n        select2Values.shift();\r\n        for(let i=0;i<select2Values.length;i++){\r\n            newData.forEach(country=>{\r\n                if(country[0]===select2Values[i]){\r\n                    topX.push(country);\r\n                }\r\n            })\r\n        }\r\n        // document.getElementById(\"controlDisplay\").style.display = \"none\";\r\n    }\r\n    else {\r\n        document.getElementById(\"controlDisplay\").style.display = \"inline\";\r\n    }\r\n    var maxYValue = 0;\r\n    topX.forEach(country => {\r\n        country[1].forEach(day => {\r\n            maxYValue = maxYValue < day[sortBy.value] ? day[sortBy.value] : maxYValue;\r\n        })\r\n    })\r\n\r\n    const yScale = d3.scaleLinear()\r\n        .domain([maxYValue, 0])\r\n        .range([0, LineGraphParent.offsetWidth * .4 - 30])\r\n        .nice()\r\n    const yAxis = d3.axisLeft(yScale)\r\n        .tickSize(-LineGraphParent.offsetWidth + 80);\r\n    svg.selectAll('.yaxis').remove();\r\n    g.append('g')\r\n        .call(yAxis)\r\n        .attr('class', 'yaxis')\r\n        .attr('transform', `translate(${0},${-margin.bottom})`)\r\n    const lineColor = d3.scaleOrdinal().range(d3.schemeCategory10);\r\n    const line = d3.line()\r\n        .curve(d3.curveMonotoneX)\r\n        .x(d => xScale(d.date))\r\n        .y(d => yScale(d[sortBy.value]));\r\n\r\n    const xScale = d3.scaleTime()\r\n        .domain(d3.extent(newData[0][1], d => d.date))\r\n        .range([0, LineGraphParent.offsetWidth - 80])\r\n\r\n    const xTicks = 10;\r\n    const xAxis = d3.axisBottom(xScale)\r\n        .ticks(xTicks)\r\n        .tickSize(-LineGraphParent.offsetHeight + 102);\r\n    svg.selectAll('.xaxis').remove();\r\n    g.append('g')\r\n        .call(xAxis)\r\n        .attr('class', 'xaxis')\r\n        .attr('transform', `translate(${0},${LineGraphParent.offsetWidth * .4 - margin.bottom - 30})`);\r\n\r\n    svg.selectAll(\".country\").remove();\r\n    var country = g.selectAll(\".country\")\r\n        .data(topX)\r\n        .enter()\r\n        .append(\"g\")\r\n        .attr(\"class\", d => `country ${d[0]}`)\r\n        .attr('transform', `translate(${-margin.left + 61},${-margin.bottom})`);\r\n\r\n    country.append('path')\r\n        .attr('fill', 'none')\r\n        .style(\"stroke\", d => lineColor(d[0]))\r\n        .attr(\"stroke-width\", 1.5)\r\n        .attr(\"d\", d => line(d[1]))\r\n\r\n    country.append('text')\r\n        .style(\"fill\", d => lineColor(d[0]))\r\n        .text(d => d[0])\r\n        .style(\"font-weight\", 600)\r\n        .attr('x', d => xScale(d[1][days - 1 - fromDay].date) - 80)\r\n        .attr('y', d => yScale(d[1][days - 1 - fromDay][sortBy.value]) - 2)\r\n        .attr('class', 'line-graph-country-legend')\r\n\r\n    svg.selectAll('.legend-circle').remove();\r\n    country.selectAll('.legend-circles-path')\r\n        .data(topX)\r\n        .enter()\r\n        .append('g')\r\n        .attr('class', 'legend-circle')\r\n        .attr('fill', d => lineColor(d[0]))\r\n        .selectAll('circle')\r\n        .data(d => d[1])\r\n        .enter()\r\n        .append('circle')\r\n        .attr(\"r\", 1.5)\r\n        .attr(\"cx\", d => xScale(d.date))\r\n        .attr(\"cy\", d => yScale(d[sortBy.value]))\r\n        .on('mouseover', function (d) {\r\n            div.style(\"display\", \"block\")\r\n            div.transition()\r\n                .duration(200)\r\n                .style(\"opacity\", 0.8);\r\n            div.html(\r\n                `<span style=\"font-size:16px\"><b>Confirmed</b>: ${d.confirmed}</span>\r\n                <br/>\r\n                <span style=\"color:black\"><b>Deaths</b>: ${d.deaths}</span>\r\n                <br/>\r\n                <span style=\"color:black\"><b>Date</b>: ${(d.date).toString().substring(0, 16)}</span>`\r\n            )\r\n                .style('left', d3.event.pageX + 10 + 'px')\r\n                .style('top', d3.event.pageY - 28 + 'px');\r\n            this.attributes[0].value = 3;\r\n            // console.log(this)\r\n        })\r\n        .on(\"mouseout\", function (d) { div.style(\"display\", \"none\"); this.attributes[0].value = 1.5; })\r\n\r\n}\r\nwindow.multiLineGraph = multiLineGraph;\r\nmodule.exports = multiLineGraph;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9tdWx0aUxpbmVHcmFwaC5qcz8xOWFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsWUFBWSxHQUFHLFdBQVc7O0FBRWxFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLHlDQUF5QztBQUN6QyxtQkFBbUIsa0NBQWtDO0FBQ3JEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxFQUFFLEdBQUcsZUFBZTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEVBQUUsR0FBRyxzREFBc0Q7O0FBRW5HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsS0FBSztBQUM1Qyx3Q0FBd0Msa0JBQWtCLEdBQUcsZUFBZTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVk7QUFDOUU7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBLHlEQUF5RCxxQ0FBcUM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxzQ0FBc0MsOEJBQThCLGdDQUFnQyxFQUFFOztBQUV0RztBQUNBO0FBQ0EiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG11bHRpTGluZUdyYXBoID0gKGNvdW50cmllcywgZGF5cywgbnVtYmVyT2ZDb3VudHJpZXNJbkxpbmVDaGFydCkgPT4ge1xyXG4gICAgdmFyIExpbmVHcmFwaFBhcmVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3b3JsZE11bHRpbGluZUNoYXJ0JykucGFyZW50RWxlbWVudDtcclxuICAgIGNvbnN0IG1hcmdpbiA9IHsgbGVmdDogNjAsIHRvcDogMzAsIHJpZ2h0OiA0NSwgYm90dG9tOiAyMCB9O1xyXG4gICAgY291bnRyaWVzLmZvckVhY2goY291bnRyeSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcclxuICAgICAgICBvcHRpb24udmFsdWUgPSBjb3VudHJ5WzBdO1xyXG4gICAgICAgIG9wdGlvbi5pbm5lckhUTUwgPSBjb3VudHJ5WzBdO1xyXG4gICAgICAgIGNvdW50cnlTZWxlY3Rpb24uYXBwZW5kQ2hpbGQob3B0aW9uKTtcclxuICAgIH0pXHJcbiAgICBjb25zdCBzdmcgPSBkMy5zZWxlY3QoJyN3b3JsZE11bHRpbGluZUNoYXJ0JylcclxuICAgICAgICAuYXR0cignd2lkdGgnLCBMaW5lR3JhcGhQYXJlbnQub2Zmc2V0V2lkdGgpXHJcbiAgICAgICAgLmF0dHIoJ2hlaWdodCcsIExpbmVHcmFwaFBhcmVudC5vZmZzZXRXaWR0aCAqIC40ICsgMjApXHJcblxyXG4gICAgY29uc3QgZyA9IHN2Zy5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7bWFyZ2luLmxlZnR9LCR7bWFyZ2luLnRvcH0pYClcclxuXHJcbiAgICAvL3NvcnRpbmcgY291bnRyeSBhY2NvcmRpbmcgdG8gY29uZmlybWVkIGNhc2VzXHJcbiAgICBjb25zdCBzb3J0QnkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNvcnRCeVwiKTtcclxuXHJcbiAgICBjb25zdCBmcm9tRGF5SW5SYW5nZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmcm9tRGF5SW5SYW5nZScpO1xyXG4gICAgZnJvbURheUluUmFuZ2UubWF4ID0gZGF5cztcclxuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmcm9tRGF5JykuaW5uZXJIVE1MID0gZnJvbURheUluUmFuZ2UudmFsdWU7XHJcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG9EYXknKS5pbm5lckhUTUwgPSBkYXlzO1xyXG5cclxuICAgIHZhciBmcm9tRGF5ID0gZnJvbURheUluUmFuZ2UudmFsdWU7XHJcbiAgICBjb3VudHJpZXMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICAgIHJldHVybiBiWzFdW2Zyb21EYXldW3NvcnRCeS52YWx1ZV0gLSBhWzFdW2Zyb21EYXldW3NvcnRCeS52YWx1ZV07XHJcbiAgICB9KVxyXG5cclxuICAgIC8vR3JhcGggZnJvbSBkYXkgWCB0byB0aWxsIGRhdGVcclxuICAgIGNvbnN0IG5ld0RhdGEgPSBbXTtcclxuICAgIGNvdW50cmllcy5mb3JFYWNoKGNvdW50cnkgPT4ge1xyXG4gICAgICAgIGxldCBuYW1lID0gY291bnRyeVswXTtcclxuICAgICAgICBsZXQgZGF0YSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tRGF5OyBpIDwgZGF5czsgaSsrKSB7XHJcbiAgICAgICAgICAgIGRhdGEucHVzaChjb3VudHJ5WzFdW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHNldCA9IFtdO1xyXG4gICAgICAgIHNldC5wdXNoKG5hbWUpO1xyXG4gICAgICAgIHNldC5wdXNoKGRhdGEpO1xyXG4gICAgICAgIG5ld0RhdGEucHVzaChzZXQpO1xyXG4gICAgfSlcclxuXHJcbiAgICB2YXIgdG9wWCA9IFtdO1xyXG4gICAgdmFyIG51bWJlck9mQ291bnRyaWVzSW5MaW5lQ2hhcnQgPSA1Oy8vZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ251bWJlck9mQ291bnRyaWVzSW5MaW5lQ2hhcnQnKS52YWx1ZTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZDb3VudHJpZXNJbkxpbmVDaGFydDsgaSsrKSB7XHJcbiAgICAgICAgdG9wWC5wdXNoKG5ld0RhdGFbaV0pO1xyXG4gICAgfVxyXG5cclxuICAgICQoXCIjY291bnRyeVNlbGVjdGlvblwiKS5zZWxlY3QyKHtcclxuICAgICAgICBwbGFjZWhvbGRlcjogXCJTZWxlY3QgY291bnRyaWVzXCIsXHJcbiAgICAgICAgYWxsb3dDbGVhcjogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCBzZWxlY3QyTGlzdCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VsZWN0Mi1jb3VudHJ5U2VsZWN0aW9uLWNvbnRhaW5lclwiKTtcclxuICAgIGlmIChzZWxlY3QyTGlzdC5jaGlsZEVsZW1lbnRDb3VudCkge1xyXG4gICAgICAgIHRvcFggPSBbXTtcclxuICAgICAgICAvL3NlbGVjdDJMaXN0LmNoaWxkcmVuLnN0eWxlLmNvbG9yID0gJ2JsYWNrJztcclxuICAgICAgICBjb25zdCBzZWxlY3QyVmFsdWVzID0gc2VsZWN0Mkxpc3QuaW5uZXJUZXh0LnNwbGl0KFwiw5dcIik7XHJcbiAgICAgICAgc2VsZWN0MlZhbHVlcy5zaGlmdCgpO1xyXG4gICAgICAgIGZvcihsZXQgaT0wO2k8c2VsZWN0MlZhbHVlcy5sZW5ndGg7aSsrKXtcclxuICAgICAgICAgICAgbmV3RGF0YS5mb3JFYWNoKGNvdW50cnk9PntcclxuICAgICAgICAgICAgICAgIGlmKGNvdW50cnlbMF09PT1zZWxlY3QyVmFsdWVzW2ldKXtcclxuICAgICAgICAgICAgICAgICAgICB0b3BYLnB1c2goY291bnRyeSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY29udHJvbERpc3BsYXlcIikuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb250cm9sRGlzcGxheVwiKS5zdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmVcIjtcclxuICAgIH1cclxuICAgIHZhciBtYXhZVmFsdWUgPSAwO1xyXG4gICAgdG9wWC5mb3JFYWNoKGNvdW50cnkgPT4ge1xyXG4gICAgICAgIGNvdW50cnlbMV0uZm9yRWFjaChkYXkgPT4ge1xyXG4gICAgICAgICAgICBtYXhZVmFsdWUgPSBtYXhZVmFsdWUgPCBkYXlbc29ydEJ5LnZhbHVlXSA/IGRheVtzb3J0QnkudmFsdWVdIDogbWF4WVZhbHVlO1xyXG4gICAgICAgIH0pXHJcbiAgICB9KVxyXG5cclxuICAgIGNvbnN0IHlTY2FsZSA9IGQzLnNjYWxlTGluZWFyKClcclxuICAgICAgICAuZG9tYWluKFttYXhZVmFsdWUsIDBdKVxyXG4gICAgICAgIC5yYW5nZShbMCwgTGluZUdyYXBoUGFyZW50Lm9mZnNldFdpZHRoICogLjQgLSAzMF0pXHJcbiAgICAgICAgLm5pY2UoKVxyXG4gICAgY29uc3QgeUF4aXMgPSBkMy5heGlzTGVmdCh5U2NhbGUpXHJcbiAgICAgICAgLnRpY2tTaXplKC1MaW5lR3JhcGhQYXJlbnQub2Zmc2V0V2lkdGggKyA4MCk7XHJcbiAgICBzdmcuc2VsZWN0QWxsKCcueWF4aXMnKS5yZW1vdmUoKTtcclxuICAgIGcuYXBwZW5kKCdnJylcclxuICAgICAgICAuY2FsbCh5QXhpcylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAneWF4aXMnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7MH0sJHstbWFyZ2luLmJvdHRvbX0pYClcclxuICAgIGNvbnN0IGxpbmVDb2xvciA9IGQzLnNjYWxlT3JkaW5hbCgpLnJhbmdlKGQzLnNjaGVtZUNhdGVnb3J5MTApO1xyXG4gICAgY29uc3QgbGluZSA9IGQzLmxpbmUoKVxyXG4gICAgICAgIC5jdXJ2ZShkMy5jdXJ2ZU1vbm90b25lWClcclxuICAgICAgICAueChkID0+IHhTY2FsZShkLmRhdGUpKVxyXG4gICAgICAgIC55KGQgPT4geVNjYWxlKGRbc29ydEJ5LnZhbHVlXSkpO1xyXG5cclxuICAgIGNvbnN0IHhTY2FsZSA9IGQzLnNjYWxlVGltZSgpXHJcbiAgICAgICAgLmRvbWFpbihkMy5leHRlbnQobmV3RGF0YVswXVsxXSwgZCA9PiBkLmRhdGUpKVxyXG4gICAgICAgIC5yYW5nZShbMCwgTGluZUdyYXBoUGFyZW50Lm9mZnNldFdpZHRoIC0gODBdKVxyXG5cclxuICAgIGNvbnN0IHhUaWNrcyA9IDEwO1xyXG4gICAgY29uc3QgeEF4aXMgPSBkMy5heGlzQm90dG9tKHhTY2FsZSlcclxuICAgICAgICAudGlja3MoeFRpY2tzKVxyXG4gICAgICAgIC50aWNrU2l6ZSgtTGluZUdyYXBoUGFyZW50Lm9mZnNldEhlaWdodCArIDEwMik7XHJcbiAgICBzdmcuc2VsZWN0QWxsKCcueGF4aXMnKS5yZW1vdmUoKTtcclxuICAgIGcuYXBwZW5kKCdnJylcclxuICAgICAgICAuY2FsbCh4QXhpcylcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAneGF4aXMnKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7MH0sJHtMaW5lR3JhcGhQYXJlbnQub2Zmc2V0V2lkdGggKiAuNCAtIG1hcmdpbi5ib3R0b20gLSAzMH0pYCk7XHJcblxyXG4gICAgc3ZnLnNlbGVjdEFsbChcIi5jb3VudHJ5XCIpLnJlbW92ZSgpO1xyXG4gICAgdmFyIGNvdW50cnkgPSBnLnNlbGVjdEFsbChcIi5jb3VudHJ5XCIpXHJcbiAgICAgICAgLmRhdGEodG9wWClcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoXCJnXCIpXHJcbiAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBkID0+IGBjb3VudHJ5ICR7ZFswXX1gKVxyXG4gICAgICAgIC5hdHRyKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7LW1hcmdpbi5sZWZ0ICsgNjF9LCR7LW1hcmdpbi5ib3R0b219KWApO1xyXG5cclxuICAgIGNvdW50cnkuYXBwZW5kKCdwYXRoJylcclxuICAgICAgICAuYXR0cignZmlsbCcsICdub25lJylcclxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgZCA9PiBsaW5lQ29sb3IoZFswXSkpXHJcbiAgICAgICAgLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMS41KVxyXG4gICAgICAgIC5hdHRyKFwiZFwiLCBkID0+IGxpbmUoZFsxXSkpXHJcblxyXG4gICAgY291bnRyeS5hcHBlbmQoJ3RleHQnKVxyXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZCA9PiBsaW5lQ29sb3IoZFswXSkpXHJcbiAgICAgICAgLnRleHQoZCA9PiBkWzBdKVxyXG4gICAgICAgIC5zdHlsZShcImZvbnQtd2VpZ2h0XCIsIDYwMClcclxuICAgICAgICAuYXR0cigneCcsIGQgPT4geFNjYWxlKGRbMV1bZGF5cyAtIDEgLSBmcm9tRGF5XS5kYXRlKSAtIDgwKVxyXG4gICAgICAgIC5hdHRyKCd5JywgZCA9PiB5U2NhbGUoZFsxXVtkYXlzIC0gMSAtIGZyb21EYXldW3NvcnRCeS52YWx1ZV0pIC0gMilcclxuICAgICAgICAuYXR0cignY2xhc3MnLCAnbGluZS1ncmFwaC1jb3VudHJ5LWxlZ2VuZCcpXHJcblxyXG4gICAgc3ZnLnNlbGVjdEFsbCgnLmxlZ2VuZC1jaXJjbGUnKS5yZW1vdmUoKTtcclxuICAgIGNvdW50cnkuc2VsZWN0QWxsKCcubGVnZW5kLWNpcmNsZXMtcGF0aCcpXHJcbiAgICAgICAgLmRhdGEodG9wWClcclxuICAgICAgICAuZW50ZXIoKVxyXG4gICAgICAgIC5hcHBlbmQoJ2cnKVxyXG4gICAgICAgIC5hdHRyKCdjbGFzcycsICdsZWdlbmQtY2lyY2xlJylcclxuICAgICAgICAuYXR0cignZmlsbCcsIGQgPT4gbGluZUNvbG9yKGRbMF0pKVxyXG4gICAgICAgIC5zZWxlY3RBbGwoJ2NpcmNsZScpXHJcbiAgICAgICAgLmRhdGEoZCA9PiBkWzFdKVxyXG4gICAgICAgIC5lbnRlcigpXHJcbiAgICAgICAgLmFwcGVuZCgnY2lyY2xlJylcclxuICAgICAgICAuYXR0cihcInJcIiwgMS41KVxyXG4gICAgICAgIC5hdHRyKFwiY3hcIiwgZCA9PiB4U2NhbGUoZC5kYXRlKSlcclxuICAgICAgICAuYXR0cihcImN5XCIsIGQgPT4geVNjYWxlKGRbc29ydEJ5LnZhbHVlXSkpXHJcbiAgICAgICAgLm9uKCdtb3VzZW92ZXInLCBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICBkaXYuc3R5bGUoXCJkaXNwbGF5XCIsIFwiYmxvY2tcIilcclxuICAgICAgICAgICAgZGl2LnRyYW5zaXRpb24oKVxyXG4gICAgICAgICAgICAgICAgLmR1cmF0aW9uKDIwMClcclxuICAgICAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMC44KTtcclxuICAgICAgICAgICAgZGl2Lmh0bWwoXHJcbiAgICAgICAgICAgICAgICBgPHNwYW4gc3R5bGU9XCJmb250LXNpemU6MTZweFwiPjxiPkNvbmZpcm1lZDwvYj46ICR7ZC5jb25maXJtZWR9PC9zcGFuPlxyXG4gICAgICAgICAgICAgICAgPGJyLz5cclxuICAgICAgICAgICAgICAgIDxzcGFuIHN0eWxlPVwiY29sb3I6YmxhY2tcIj48Yj5EZWF0aHM8L2I+OiAke2QuZGVhdGhzfTwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDxici8+XHJcbiAgICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cImNvbG9yOmJsYWNrXCI+PGI+RGF0ZTwvYj46ICR7KGQuZGF0ZSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMCwgMTYpfTwvc3Bhbj5gXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgIC5zdHlsZSgnbGVmdCcsIGQzLmV2ZW50LnBhZ2VYICsgMTAgKyAncHgnKVxyXG4gICAgICAgICAgICAgICAgLnN0eWxlKCd0b3AnLCBkMy5ldmVudC5wYWdlWSAtIDI4ICsgJ3B4Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlc1swXS52YWx1ZSA9IDM7XHJcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKHRoaXMpXHJcbiAgICAgICAgfSlcclxuICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbiAoZCkgeyBkaXYuc3R5bGUoXCJkaXNwbGF5XCIsIFwibm9uZVwiKTsgdGhpcy5hdHRyaWJ1dGVzWzBdLnZhbHVlID0gMS41OyB9KVxyXG5cclxufVxyXG53aW5kb3cubXVsdGlMaW5lR3JhcGggPSBtdWx0aUxpbmVHcmFwaDtcclxubW9kdWxlLmV4cG9ydHMgPSBtdWx0aUxpbmVHcmFwaDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")}]);